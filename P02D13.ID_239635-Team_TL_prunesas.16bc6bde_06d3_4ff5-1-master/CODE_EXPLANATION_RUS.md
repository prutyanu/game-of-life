# Подробное описание кода Game of Life

## Оглавление
1. [Общая структура программы](#общая-структура-программы)
2. [Константы и макросы](#константы-и-макросы)
3. [Объявление функций](#объявление-функций)
4. [Функция main()](#функция-main)
5. [Функции инициализации](#функции-инициализации)
6. [Функции отображения](#функции-отображения)
7. [Функции логики игры](#функции-логики-игры)
8. [Вспомогательные функции](#вспомогательные-функции)

---

## Общая структура программы

Программа реализует клеточный автомат "Игра Жизнь" (Game of Life) с интерактивным управлением в терминале.

**Принцип работы:**
1. Программа считывает начальное состояние поля из stdin
2. Инициализирует графический режим с помощью библиотеки ncurses
3. В бесконечном цикле отображает поле и обновляет его по правилам игры
4. Пользователь может управлять скоростью и завершить игру

---

## Константы и макросы

```c
#define WIDTH 80
#define HEIGHT 25
```
**Что это:** Определение размеров игрового поля
**Как работает:**
- `WIDTH` - ширина поля (80 клеток)
- `HEIGHT` - высота поля (25 клеток)
- Эти константы используются во всех функциях для создания массивов и циклов

```c
#define ALIVE 'O'
#define DEAD '.'
```
**Что это:** Символы для отображения клеток
**Как работает:**
- `ALIVE` - символ живой клетки (буква O)
- `DEAD` - символ мертвой клетки (точка)
- Используются в функции отрисовки поля

```c
#define MIN_DELAY 10000
#define MAX_DELAY 500000
#define DELAY_STEP 50000
```
**Что это:** Параметры управления скоростью игры
**Как работает:**
- `MIN_DELAY` - минимальная задержка между кадрами (10 тысяч микросекунд = 0.01 секунды)
- `MAX_DELAY` - максимальная задержка (500 тысяч микросекунд = 0.5 секунды)
- `DELAY_STEP` - шаг изменения скорости (50 тысяч микросекунд)

---

## Объявление функций

```c
void initialize_field(int field[HEIGHT][WIDTH]);
void read_initial_state(int field[HEIGHT][WIDTH]);
void draw_field(int field[HEIGHT][WIDTH]);
int count_neighbors(int field[HEIGHT][WIDTH], int y, int x);
void update_field(int field[HEIGHT][WIDTH], int new_field[HEIGHT][WIDTH]);
void copy_field(int source[HEIGHT][WIDTH], int dest[HEIGHT][WIDTH]);
int check_valid_input(int rows, int cols);
```

**Что это:** Прототипы (объявления) всех функций программы
**Зачем это нужно:** Компилятор языка C должен знать о существовании функций до их вызова
**Как работает:** Эти строки говорят компилятору:
- Какие функции существуют
- Какие параметры они принимают (массивы, целые числа)
- Что они возвращают (void = ничего, int = целое число)

---

## Функция main()

### Объявление переменных

```c
int main() {
    int field[HEIGHT][WIDTH];
    int new_field[HEIGHT][WIDTH];
    int delay = 100000;
    int running = 1;
```

**Что объявляется:**
- `field[HEIGHT][WIDTH]` - текущее состояние игрового поля (двумерный массив 25x80)
- `new_field[HEIGHT][WIDTH]` - следующее состояние поля (для вычисления нового поколения)
- `delay` - задержка между кадрами в микросекундах (изначально 100000 = 0.1 секунды)
- `running` - флаг работы программы (1 = работает, 0 = завершить)

**Как работает массив:**
- `field[i][j]` - где i - номер строки (0-24), j - номер столбца (0-79)
- Значение 0 = мертвая клетка, 1 = живая клетка

### Инициализация

```c
    initialize_field(field);
    read_initial_state(field);
```

**Что происходит:**
1. `initialize_field(field)` - заполняет все поле нулями (мертвые клетки)
2. `read_initial_state(field)` - считывает начальную конфигурацию из stdin

**Как вызывается функция:**
- Пишем имя функции и передаем ей параметр `field` (весь массив)
- Функция получает доступ к массиву и может его изменять

### Настройка ncurses

```c
    initscr();
    noecho();
    cbreak();
    nodelay(stdscr, TRUE);
    curs_set(0);
```

**Что это:** Инициализация библиотеки ncurses для работы с терминалом
**Как работает каждая команда:**
- `initscr()` - инициализирует режим ncurses, готовит терминал к работе
- `noecho()` - отключает отображение нажатых клавиш на экране
- `cbreak()` - включает режим немедленной обработки нажатий (без Enter)
- `nodelay(stdscr, TRUE)` - включает неблокирующий режим ввода (getch() не ждет нажатия)
- `curs_set(0)` - скрывает курсор

### Основной игровой цикл

```c
    while (running) {
        clear();
        draw_field(field);
        mvprintw(HEIGHT + 1, 0, "Controls: A - faster, Z - slower, SPACE - exit");
        mvprintw(HEIGHT + 2, 0, "Speed delay: %d microseconds", delay);
        refresh();
```

**Что происходит:**
1. `while (running)` - цикл продолжается, пока running = 1
2. `clear()` - очищает экран терминала
3. `draw_field(field)` - рисует текущее состояние поля
4. `mvprintw()` - выводит текст в указанную позицию экрана
   - `HEIGHT + 1` означает строка 26 (под полем)
   - `0` означает начало строки
5. `refresh()` - обновляет экран, показывает все изменения

### Обработка ввода

```c
        int ch = getch();
        if (ch == ' ') {
            running = 0;
        } else if (ch == 'a' || ch == 'A') {
            if (delay > MIN_DELAY) {
                delay -= DELAY_STEP;
            }
        } else if (ch == 'z' || ch == 'Z') {
            if (delay < MAX_DELAY) {
                delay += DELAY_STEP;
            }
        }
```

**Что происходит:**
1. `getch()` - пытается прочитать нажатую клавишу (не блокирует программу)
2. Если нажат пробел (' ') - устанавливаем `running = 0` для выхода
3. Если нажата 'A' или 'a':
   - Проверяем, что delay больше минимума
   - Уменьшаем delay (ускоряем игру)
4. Если нажата 'Z' или 'z':
   - Проверяем, что delay меньше максимума
   - Увеличиваем delay (замедляем игру)

**Логика проверки:**
- `ch == 'a' || ch == 'A'` - это логическое ИЛИ, срабатывает при любой букве (большой или маленькой)

### Обновление состояния

```c
        update_field(field, new_field);
        copy_field(new_field, field);
        usleep(delay);
    }
```

**Что происходит:**
1. `update_field(field, new_field)` - вычисляет следующее поколение
   - Берет текущее поле `field`
   - Записывает результат в `new_field`
2. `copy_field(new_field, field)` - копирует новое поколение в текущее поле
3. `usleep(delay)` - задержка (пауза) на указанное количество микросекунд

**Почему два массива:**
- По правилам игры все изменения происходят одновременно
- Нельзя изменять поле во время подсчета соседей
- Поэтому вычисляем в новый массив, затем копируем

### Завершение

```c
    endwin();
    return 0;
}
```

**Что происходит:**
- `endwin()` - закрывает режим ncurses, восстанавливает обычный режим терминала
- `return 0` - возвращает код успешного завершения программы

---

## Функции инициализации

### initialize_field()

```c
void initialize_field(int field[HEIGHT][WIDTH]) {
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            field[i][j] = 0;
        }
    }
}
```

**Что делает:** Заполняет все поле нулями (мертвые клетки)

**Как работает:**
1. Объявляет параметр `field` - двумерный массив
2. Внешний цикл `for (int i = 0; i < HEIGHT; i++)`:
   - Переменная `i` идет от 0 до 24 (строки)
   - `i++` увеличивает i на 1 после каждой итерации
3. Внутренний цикл `for (int j = 0; j < WIDTH; j++)`:
   - Переменная `j` идет от 0 до 79 (столбцы)
4. `field[i][j] = 0` - устанавливает клетку в позиции [i][j] в 0

**Пример работы:**
- При i=0, j=0: field[0][0] = 0
- При i=0, j=1: field[0][1] = 0
- ... и так далее для всех 2000 клеток (25 × 80)

### read_initial_state()

```c
void read_initial_state(int field[HEIGHT][WIDTH]) {
    int rows = 0;
    int cols = 0;
    char line[WIDTH + 2];
```

**Что объявляется:**
- `rows` - счетчик прочитанных строк
- `cols` - счетчик символов в строке
- `line[WIDTH + 2]` - буфер для чтения одной строки (82 символа: 80 для поля + символ новой строки + нулевой байт)

```c
    while (fgets(line, sizeof(line), stdin) != NULL && rows < HEIGHT) {
        cols = 0;
```

**Как работает:**
- `fgets(line, sizeof(line), stdin)` - читает одну строку из стандартного ввода
  - `line` - куда сохранить
  - `sizeof(line)` - максимальный размер (82)
  - `stdin` - откуда читать (стандартный ввод)
  - Возвращает NULL если данных больше нет
- `&& rows < HEIGHT` - и проверяет, что не превышено количество строк
- `cols = 0` - сбрасываем счетчик столбцов для новой строки

```c
        for (int i = 0; line[i] != '\0' && line[i] != '\n' && cols < WIDTH; i++) {
            if (line[i] == ALIVE || line[i] == '1') {
                field[rows][cols] = 1;
            } else if (line[i] == DEAD || line[i] == '0' || line[i] == ' ') {
                field[rows][cols] = 0;
            } else {
                continue;
            }
            cols++;
        }
        rows++;
    }
```

**Как работает:**
1. Цикл идет по символам строки:
   - `line[i] != '\0'` - пока не конец строки (нулевой байт)
   - `line[i] != '\n'` - и не символ новой строки
   - `cols < WIDTH` - и не превышена ширина поля
2. Проверяем каждый символ:
   - Если 'O' или '1' - ставим живую клетку (1)
   - Если '.' или '0' или пробел - ставим мертвую клетку (0)
   - Если другой символ - пропускаем (continue переходит к следующей итерации)
3. `cols++` - увеличиваем счетчик столбцов
4. `rows++` - после обработки строки увеличиваем счетчик строк

```c
    if (!check_valid_input(rows, cols)) {
        endwin();
        fprintf(stderr, "Error: Invalid input dimensions\n");
        exit(1);
    }
}
```

**Что происходит:**
- Вызываем функцию проверки корректности ввода
- `!` означает НЕ (если функция вернула 0, то есть ложь)
- Если ввод некорректный:
  - `endwin()` - закрываем ncurses
  - `fprintf(stderr, ...)` - выводим ошибку в поток ошибок
  - `exit(1)` - завершаем программу с кодом ошибки 1

### check_valid_input()

```c
int check_valid_input(int rows, int cols) {
    if (rows > HEIGHT || cols > WIDTH || rows == 0 || cols == 0) {
        return 0;
    }
    return 1;
}
```

**Что делает:** Проверяет корректность размеров введенного поля

**Как работает:**
- Проверяет условия:
  - `rows > HEIGHT` - строк больше чем допустимо
  - `cols > WIDTH` - столбцов больше чем допустимо
  - `rows == 0` - не прочитано ни одной строки
  - `cols == 0` - не прочитано ни одного символа
- `||` означает логическое ИЛИ (достаточно одного истинного условия)
- Возвращает 0 (ложь) если размеры неверны, 1 (истина) если все в порядке

---

## Функции отображения

### draw_field()

```c
void draw_field(int field[HEIGHT][WIDTH]) {
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            if (field[i][j] == 1) {
                mvaddch(i, j, ALIVE);
            } else {
                mvaddch(i, j, DEAD);
            }
        }
    }
}
```

**Что делает:** Рисует все клетки поля на экране

**Как работает:**
1. Проходим по всем клеткам двумя вложенными циклами
2. Для каждой клетки:
   - Проверяем значение: `field[i][j] == 1` (живая?)
   - `mvaddch(i, j, символ)` - выводит символ в позицию (строка i, столбец j)
   - Если живая - выводим 'O' (ALIVE)
   - Если мертвая - выводим '.' (DEAD)

**Функция mvaddch:**
- `mv` = move (переместить курсор)
- `add` = добавить
- `ch` = character (символ)
- Параметры: (y, x, символ) - координаты и что вывести

---

## Функции логики игры

### count_neighbors()

```c
int count_neighbors(int field[HEIGHT][WIDTH], int y, int x) {
    int count = 0;
    int dy, dx, ny, nx;
```

**Что делает:** Подсчитывает количество живых соседей для клетки в позиции (y, x)

**Что объявляется:**
- `count` - счетчик живых соседей
- `dy, dx` - смещения по осям (delta y, delta x)
- `ny, nx` - координаты соседа (neighbor y, neighbor x)

```c
    for (dy = -1; dy <= 1; dy++) {
        for (dx = -1; dx <= 1; dx++) {
            if (dy == 0 && dx == 0) {
                continue;
            }
```

**Как работает:**
1. Внешний цикл: `dy` от -1 до 1 (проверяем строку выше, текущую, ниже)
2. Внутренний цикл: `dx` от -1 до 1 (проверяем столбец слева, текущий, справа)
3. Это дает 9 клеток: 3×3 квадрат вокруг текущей клетки
4. `if (dy == 0 && dx == 0)` - пропускаем саму клетку (не считаем ее соседом)

**Пример смещений:**
```
(-1,-1) (-1,0) (-1,1)
( 0,-1) ( 0,0) ( 0,1)  <- (0,0) пропускаем
( 1,-1) ( 1,0) ( 1,1)
```

```c
            ny = (y + dy + HEIGHT) % HEIGHT;
            nx = (x + dx + WIDTH) % WIDTH;
```

**Что происходит:** Вычисляем координаты соседа с учетом замыкания поля

**Как работает формула:**
- `y + dy` - новая координата по вертикали
- `+ HEIGHT` - добавляем высоту поля (для обработки отрицательных значений)
- `% HEIGHT` - остаток от деления (оператор модуля)

**Примеры:**
- Клетка в позиции y=0 (верхний край), сосед сверху dy=-1:
  - ny = (0 + (-1) + 25) % 25 = 24 % 25 = 24 (нижний край)
- Клетка в позиции y=24 (нижний край), сосед снизу dy=1:
  - ny = (24 + 1 + 25) % 25 = 50 % 25 = 0 (верхний край)
- Обычная клетка y=10, сосед сверху dy=-1:
  - ny = (10 + (-1) + 25) % 25 = 34 % 25 = 9

**Зачем это нужно:** Поле "замкнуто само на себя" - правый край соединяется с левым, верхний с нижним (как тор)

```c
            if (field[ny][nx] == 1) {
                count++;
            }
        }
    }
    return count;
}
```

**Что происходит:**
- Если сосед живой (`field[ny][nx] == 1`) - увеличиваем счетчик
- После проверки всех 8 соседей возвращаем итоговое количество

### update_field()

```c
void update_field(int field[HEIGHT][WIDTH],
                  int new_field[HEIGHT][WIDTH]) {
    int neighbors;
```

**Что делает:** Вычисляет следующее поколение клеток по правилам Game of Life

**Параметры:**
- `field` - текущее состояние (откуда читаем)
- `new_field` - новое состояние (куда пишем)

```c
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            neighbors = count_neighbors(field, i, j);
```

**Что происходит:**
1. Проходим по всем клеткам поля
2. Для каждой клетки вызываем `count_neighbors()` - получаем количество живых соседей

```c
            if (field[i][j] == 1) {
                if (neighbors == 2 || neighbors == 3) {
                    new_field[i][j] = 1;
                } else {
                    new_field[i][j] = 0;
                }
```

**Правила для живой клетки:**
- Если клетка жива (`field[i][j] == 1`)
- И у нее 2 или 3 соседа - она выживает (`new_field[i][j] = 1`)
- Иначе (меньше 2 или больше 3) - умирает (`new_field[i][j] = 0`)

**Объяснение:**
- Меньше 2 соседей - умирает от одиночества
- 2 или 3 соседа - оптимально, выживает
- Больше 3 соседей - умирает от перенаселения

```c
            } else {
                if (neighbors == 3) {
                    new_field[i][j] = 1;
                } else {
                    new_field[i][j] = 0;
                }
            }
        }
    }
}
```

**Правила для мертвой клетки:**
- Если клетка мертва (иначе = else)
- И у нее ровно 3 соседа - рождается новая клетка (`new_field[i][j] = 1`)
- Иначе - остается мертвой (`new_field[i][j] = 0`)

**Объяснение:**
- Ровно 3 соседа - размножение
- Любое другое количество - ничего не происходит

---

## Вспомогательные функции

### copy_field()

```c
void copy_field(int source[HEIGHT][WIDTH], int dest[HEIGHT][WIDTH]) {
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            dest[i][j] = source[i][j];
        }
    }
}
```

**Что делает:** Копирует содержимое одного поля в другое

**Как работает:**
1. Проходим по всем клеткам
2. Копируем значение из source в dest
3. `dest[i][j] = source[i][j]` - присваиваем значение

**Зачем нужна:**
- После вычисления нового поколения в `new_field`
- Нужно скопировать его обратно в `field` для следующей итерации
- Нельзя просто присвоить массивы в C, нужно копировать поэлементно

---

## Общий алгоритм работы программы

1. **Запуск:**
   - Программа запускается из терминала
   - Пользователь перенаправляет файл с начальной конфигурацией в stdin

2. **Инициализация:**
   - Создаются два массива (текущее и новое поколение)
   - Поле заполняется нулями
   - Считывается начальная конфигурация из файла
   - Инициализируется ncurses (графический режим терминала)

3. **Игровой цикл (повторяется бесконечно пока running=1):**
   - Очистка экрана
   - Отрисовка текущего состояния поля
   - Вывод подсказок по управлению
   - Обновление экрана
   - Проверка нажатых клавиш:
     - Пробел → завершение (running=0)
     - A → ускорение (уменьшение delay)
     - Z → замедление (увеличение delay)
   - Вычисление нового поколения:
     - Для каждой клетки подсчитываются соседи
     - Применяются правила Game of Life
     - Результат записывается в новый массив
   - Копирование нового поколения в текущее
   - Задержка (пауза на delay микросекунд)

4. **Завершение:**
   - Выход из режима ncurses
   - Возврат управления терминалу
   - Программа завершается

---

## Ключевые концепции

### Двумерный массив
- `int field[HEIGHT][WIDTH]` создает таблицу из 25 строк и 80 столбцов
- Обращение: `field[строка][столбец]`
- Хранится в памяти непрерывно, строка за строкой

### Циклы
- `for (int i = 0; i < N; i++)` - повторяет код N раз
- Вложенные циклы для обхода двумерного массива
- `continue` - переходит к следующей итерации
- `break` - выходит из цикла

### Условия
- `if (условие) { код }` - выполняется если условие истинно
- `else { код }` - выполняется если условие ложно
- Логические операторы: `&&` (И), `||` (ИЛИ), `!` (НЕ)
- Операторы сравнения: `==` (равно), `!=` (не равно), `<`, `>`, `<=`, `>=`

### Функции
- Объявление: `тип_возвращаемого_значения имя(параметры)`
- Вызов: `имя(аргументы)`
- `void` - функция ничего не возвращает
- `return значение` - возвращает значение и завершает функцию

### Библиотека ncurses
- Позволяет управлять терминалом как графическим экраном
- Можно рисовать в любой позиции экрана
- Получать нажатия клавиш без блокировки программы
- Скрывать курсор, отключать эхо и т.д.

### Замыкание поля (тороидальная топология)
- Правый край соединен с левым
- Верхний край соединен с нижним
- Реализуется через операцию модуля: `(координата + смещение + размер) % размер`
- Обеспечивает бесшовный переход через границы

---

## Заключение

Эта программа демонстрирует:
- Работу с двумерными массивами
- Реализацию клеточного автомата
- Интерактивное управление в терминале
- Структурное программирование (разбиение на функции)
- Графический вывод с помощью ncurses

Каждая функция выполняет одну четкую задачу, что делает код понятным и легким для модификации.
