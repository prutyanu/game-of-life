# Руководство по реализации Game of Life

## Цель проекта

Написать программу на языке C, реализующую клеточный автомат "Игра Жизнь" (Conway's Game of Life) с интерактивным управлением в терминале.

---

## Требования к программе

### Основные параметры:
- Размер поля: **80 × 25 клеток**
- Топология: **тороидальная** (поле замкнуто само на себя)
- Графика: **ASCII-символы** в терминале
- Управление: **интерактивное** (изменение скорости, выход)
- Инициализация: через **stdin** (перенаправление файла)

---

## Шаг 1. Подключение библиотек

### Необходимые заголовочные файлы:

```c
#include <ncurses/ncurses.h>  // Для графики в терминале
#include <stdio.h>             // Для работы с вводом/выводом
#include <unistd.h>            // Для функции задержки
```

**Зачем нужны:**
- `ncurses.h` — управление терминалом (отрисовка, получение нажатий клавиш)
- `stdio.h` — чтение начального состояния, вывод ошибок
- `unistd.h` — функция `usleep()` для контроля скорости игры

---

## Шаг 2. Определение констант

### Константы для размеров поля:
- Ширина поля (80 клеток)
- Высота поля (25 клеток)

### Константы для отображения:
- Символ живой клетки (например, 'O')
- Символ мертвой клетки (например, '.')

### Константы для управления скоростью:
- Минимальная задержка между кадрами
- Максимальная задержка между кадрами
- Шаг изменения скорости

---

## Шаг 3. Структура данных

### Игровое поле:
Используйте **двумерный статический массив целых чисел**:
- Размер: HEIGHT × WIDTH
- Значения: 0 (мертвая клетка), 1 (живая клетка)

**Важно:** Нужно два массива:
1. Текущее поколение
2. Следующее поколение (для одновременного обновления всех клеток)

---

## Шаг 4. Необходимые функции

### 4.1. Функция инициализации поля
**Назначение:** Заполнить все поле нулями (мертвые клетки)

**Параметры:**
- Двумерный массив игрового поля

**Что делает:**
- Проходит по всем клеткам
- Устанавливает значение 0

---

### 4.2. Функция чтения начального состояния
**Назначение:** Считать начальную конфигурацию из stdin

**Параметры:**
- Двумерный массив игрового поля

**Возвращает:**
- Код ошибки (0 - успех, 1 - ошибка)

**Что делает:**
- Читает строки посимвольно (функция `fgets`)
- Распознает символы живых клеток ('O' или '1')
- Распознает символы мертвых клеток ('.' или '0' или пробел)
- Заполняет массив соответствующими значениями
- Проверяет корректность размеров

---

### 4.3. Функция проверки валидности ввода
**Назначение:** Проверить, что размеры введенного поля корректны

**Параметры:**
- Количество прочитанных строк
- Количество прочитанных столбцов

**Возвращает:**
- 1 если корректно, 0 если некорректно

**Что проверяет:**
- Размеры не превышают максимальные
- Размеры не нулевые

---

### 4.4. Функция отрисовки поля
**Назначение:** Отобразить текущее состояние поля в терминале

**Параметры:**
- Двумерный массив игрового поля

**Что делает:**
- Проходит по всем клеткам
- Использует функции ncurses для вывода символа в нужную позицию
- Живая клетка → выводит символ 'O'
- Мертвая клетка → выводит символ '.'

---

### 4.5. Функция подсчета соседей
**Назначение:** Подсчитать количество живых соседей у клетки

**Параметры:**
- Двумерный массив игрового поля
- Координаты клетки (y, x)

**Возвращает:**
- Количество живых соседей (от 0 до 8)

**Что делает:**
- Проверяет все 8 соседних клеток
- Учитывает **тороидальную топологию** (края замыкаются)
- Использует операцию модуля (%) для замыкания границ
- Формула: `(координата + смещение + размер) % размер`

**Важно:** Не считать саму клетку как соседа!

---

### 4.6. Функция вычисления следующего поколения
**Назначение:** Применить правила Game of Life ко всем клеткам

**Параметры:**
- Текущее поле (откуда читаем)
- Новое поле (куда пишем)

**Что делает:**
- Для каждой клетки вызывает функцию подсчета соседей
- Применяет правила:
  - **Живая клетка с 2-3 соседями** → выживает
  - **Живая клетка с другим количеством** → умирает
  - **Мертвая клетка с ровно 3 соседями** → оживает
  - **Остальные мертвые клетки** → остаются мертвыми

---

### 4.7. Функция копирования полей
**Назначение:** Скопировать содержимое одного массива в другой

**Параметры:**
- Исходный массив
- Целевой массив

**Что делает:**
- Поэлементно копирует значения из источника в цель

---

## Шаг 5. Основная функция main()

### 5.1. Объявление переменных
- Два двумерных массива (текущее и новое поколение)
- Переменная для задержки между кадрами
- Флаг продолжения игры

### 5.2. Инициализация
1. Заполнить поле нулями
2. Прочитать начальное состояние из stdin
3. Проверить корректность ввода
4. Если ошибка — вывести сообщение и завершить программу

### 5.3. Настройка ncurses
Инициализировать терминал:
- Включить режим ncurses
- Отключить отображение нажатых клавиш
- Включить режим немедленной обработки нажатий
- Включить неблокирующий ввод
- Скрыть курсор

### 5.4. Главный игровой цикл
**Повторять, пока не нажата клавиша выхода:**

1. Очистить экран
2. Отрисовать текущее состояние поля
3. Вывести подсказки по управлению
4. Вывести текущую скорость
5. Обновить экран
6. Проверить нажатую клавишу:
   - **Пробел / Q / ESC** → установить флаг выхода
   - **A** → ускорить (уменьшить задержку)
   - **Z** → замедлить (увеличить задержку)
7. Вычислить следующее поколение
8. Скопировать новое поколение в текущее
9. Сделать паузу (задержка)

### 5.5. Завершение
- Закрыть режим ncurses
- Вернуть управление терминалу
- Вернуть код успешного завершения

---

## Шаг 6. Правила Game of Life

### Для живой клетки:
```
Количество соседей | Результат
-------------------|----------
0-1                | Умирает (одиночество)
2-3                | Выживает
4-8                | Умирает (перенаселение)
```

### Для мертвой клетки:
```
Количество соседей | Результат
-------------------|----------
3                  | Оживает (размножение)
Другое             | Остается мертвой
```

---

## Шаг 7. Тороидальная топология

### Принцип замыкания:
Поле замкнуто само на себя как поверхность тора:
- Правый край → Левый край
- Левый край → Правый край
- Верхний край → Нижний край
- Нижний край → Верхний край

### Формула для вычисления координат соседа:
```c
new_coordinate = (coordinate + offset + SIZE) % SIZE
```

**Примеры:**
- Сосед справа от правого края: `(79 + 1 + 80) % 80 = 0` (левый край)
- Сосед слева от левого края: `(0 - 1 + 80) % 80 = 79` (правый край)

---

## Шаг 8. Управление в ncurses

### Инициализация терминала:
1. `initscr()` — инициализация ncurses
2. `noecho()` — не показывать нажатые клавиши
3. `cbreak()` — обрабатывать нажатия без Enter
4. `nodelay(stdscr, TRUE)` — неблокирующий ввод
5. `curs_set(0)` — скрыть курсор

### Работа с экраном:
- `clear()` — очистить экран
- `mvaddch(y, x, symbol)` — вывести символ в позицию
- `mvprintw(y, x, text, ...)` — вывести текст (как printf)
- `refresh()` — обновить экран
- `getch()` — прочитать нажатую клавишу (неблокирующе)

### Завершение:
- `endwin()` — закрыть ncurses, вернуть терминал в обычный режим

---

## Шаг 9. Чтение из stdin

### Как работает перенаправление:
```bash
./game_of_life < input.txt
```
- Содержимое файла `input.txt` становится стандартным вводом
- Программа читает его через `fgets(line, size, stdin)`

### Формат входного файла:
- 25 строк по 80 символов
- Символы: `O` или `1` — живая клетка
- Символы: `.` или `0` или пробел — мертвая клетка

---

## Шаг 10. Компиляция и запуск

### Компиляция:
```bash
gcc -Wall -Wextra -o game_of_life src/game_of_life.c -lncursesw
```

**Флаги:**
- `-Wall` — включить предупреждения
- `-Wextra` — дополнительные предупреждения
- `-o game_of_life` — имя выходного файла
- `-lncursesw` — подключить библиотеку ncurses

### Запуск:
```bash
./game_of_life < input_file.txt
```

---

## Контрольный список реализации

### Базовая функциональность:
- [ ] Инициализация поля
- [ ] Чтение начального состояния из stdin
- [ ] Проверка корректности входных данных
- [ ] Отрисовка поля в терминале
- [ ] Подсчет соседей клетки
- [ ] Вычисление следующего поколения
- [ ] Копирование массивов
- [ ] Главный игровой цикл

### Тороидальная топология:
- [ ] Правый край замыкается на левый
- [ ] Левый край замыкается на правый
- [ ] Верхний край замыкается на нижний
- [ ] Нижний край замыкается на верхний

### Интерактивность:
- [ ] Изменение скорости (клавиши A/Z)
- [ ] Выход из программы (Q/ESC/Пробел)
- [ ] Отображение подсказок по управлению
- [ ] Отображение текущей скорости

### Правила Game of Life:
- [ ] Живая клетка с 2 соседями выживает
- [ ] Живая клетка с 3 соседями выживает
- [ ] Живая клетка с другим количеством умирает
- [ ] Мертвая клетка с 3 соседями оживает
- [ ] Мертвая клетка с другим количеством остается мертвой

### Требования к коду:
- [ ] Не более 42 строк в функции
- [ ] Нет использования `exit()`
- [ ] Нет использования `system()`
- [ ] Статические массивы (без malloc/free)
- [ ] Код проходит clang-format
- [ ] Код проходит cppcheck
- [ ] Нет утечек памяти

---

## Советы по реализации

### 1. Начните с простого
Сначала реализуйте базовую версию без ncurses:
- Читайте поле
- Вычисляйте одно поколение
- Выводите результат обычным printf

### 2. Затем добавьте графику
- Подключите ncurses
- Реализуйте отрисовку
- Добавьте главный цикл

### 3. Добавьте интерактивность
- Обработка нажатий клавиш
- Изменение скорости
- Выход из программы

### 4. Проверьте тороидальность
Создайте тестовый файл с фигурой у края поля и убедитесь, что она корректно переходит через границу.

### 5. Тестируйте на разных конфигурациях
Создайте минимум 5 начальных файлов:
- Устойчивая фигура (блок 2×2)
- Периодическая фигура (мигалка)
- Движущаяся фигура (планер)
- Сложная периодическая (пульсар)
- Пользовательская конфигурация

---

## Типичные ошибки

### 1. Забыли про тороидальность
❌ Неправильно: `ny = y + dy; nx = x + dx;`
✅ Правильно: `ny = (y + dy + HEIGHT) % HEIGHT;`

### 2. Изменяют поле во время подсчета
❌ Неправильно: Записывают в тот же массив
✅ Правильно: Используют два массива

### 3. Считают саму клетку как соседа
❌ Неправильно: Проверяют все 9 клеток
✅ Правильно: Пропускают клетку (0, 0)

### 4. Не проверяют корректность ввода
❌ Неправильно: Читают без проверки
✅ Правильно: Проверяют размеры и возвращают код ошибки

### 5. Используют exit() вместо return
❌ Неправильно: `exit(1);` (запрещено требованиями)
✅ Правильно: `return 1;` из main()

---

## Заключение

Следуя этому руководству, вы сможете самостоятельно реализовать Game of Life с правильной архитектурой и всеми необходимыми функциями. Программа будет:
- Простой и понятной
- Соответствовать всем требованиям
- Легко проходить тесты
- Работать корректно и эффективно

Удачи в реализации! 🎯
