# Руководство по проекту построения графиков функций

## Оглавление
1. [Общая архитектура проекта](#общая-архитектура-проекта)
2. [Модуль stack.c/h - Стек](#модуль-stackch---стек)
3. [Модуль graphics.c/h - Графика](#модуль-graphicsch---графика)
4. [Модуль parser.c/h - Парсер и вычисления](#модуль-parserch---парсер-и-вычисления)
5. [Модуль graph.c - Главная программа](#модуль-graphc---главная-программа)
6. [Поток выполнения программы](#поток-выполнения-программы)

---

## Общая архитектура проекта

```
Ввод строки → Токенизация → Валидация → Преобразование в RPN → 
→ Вычисление для каждой точки → Отрисовка графика
```

**Модули проекта:**
- `stack.c/h` - реализация стека (базовая структура данных)
- `graphics.c/h` - инициализация и вывод холста для графика
- `parser.c/h` - токенизация, валидация, преобразование в RPN, вычисление
- `graph.c` - главная программа, координирует работу всех модулей

---

## Модуль stack.c/h - Стек

### Структуры данных

```c
typedef struct StackNode {
    void* data;              // Указатель на данные любого типа
    struct StackNode* next;  // Указатель на следующий элемент
} StackNode;

typedef struct {
    StackNode* top;          // Указатель на вершину стека
} Stack;
```

### Функция: create_stack()
```c
Stack* create_stack(void)
```
**Назначение:** Создание нового пустого стека

**Логика работы:**
1. Выделяет память под структуру Stack
2. Инициализирует top как NULL (пустой стек)
3. Возвращает указатель на созданный стек

**Возвращает:** Указатель на Stack или NULL при ошибке

---

### Функция: push()
```c
void push(Stack* stack, void* data)
```
**Назначение:** Добавление элемента на вершину стека

**Параметры:**
- `stack` - указатель на стек
- `data` - указатель на данные для добавления

**Логика работы:**
1. Проверяет, что stack не NULL
2. Создает новый узел StackNode
3. Помещает data в новый узел
4. Новый узел указывает на текущую вершину (next = stack->top)
5. Обновляет вершину стека (stack->top = newNode)

**Сложность:** O(1)

---

### Функция: pop()
```c
void* pop(Stack* stack)
```
**Назначение:** Извлечение элемента с вершины стека

**Логика работы:**
1. Проверяет, что стек не пуст
2. Сохраняет указатель на вершину (temp)
3. Извлекает данные из вершины
4. Перемещает вершину на следующий элемент (stack->top = temp->next)
5. Освобождает память узла (но НЕ данные!)
6. Возвращает указатель на данные

**Возвращает:** Указатель на данные или NULL если стек пуст

**Важно:** Вызывающая функция отвечает за освобождение памяти данных!

---

### Функция: peek()
```c
void* peek(Stack* stack)
```
**Назначение:** Просмотр элемента на вершине без извлечения

**Логика работы:**
1. Проверяет, что стек не пуст
2. Возвращает указатель на данные вершины

**Возвращает:** Указатель на данные или NULL

---

### Функция: is_empty()
```c
int is_empty(Stack* stack)
```
**Назначение:** Проверка пустоты стека

**Логика работы:**
1. Возвращает 1 (true) если stack->top == NULL
2. Возвращает 0 (false) в противном случае

---

### Функция: free_stack()
```c
void free_stack(Stack* stack)
```
**Назначение:** Освобождение памяти стека

**Логика работы:**
1. Извлекает все элементы из стека (вызывая pop)
2. Освобождает память самой структуры Stack

**Важно:** НЕ освобождает память данных внутри узлов!

---

## Модуль graphics.c/h - Графика

### Константы
```c
#define CANVAS_HEIGHT 25  // Высота холста
#define CANVAS_WIDTH 80   // Ширина холста
```

### Функция: init_canvas()
```c
void init_canvas(char canvas[CANVAS_HEIGHT][CANVAS_WIDTH])
```
**Назначение:** Инициализация холста точками

**Параметры:**
- `canvas` - двумерный массив символов [25][80]

**Логика работы:**
1. Внешний цикл по строкам (i от 0 до 24)
2. Внутренний цикл по столбцам (j от 0 до 79)
3. Каждую ячейку заполняет символом '.'

**Особенность:** Использует while вместо for (структурное программирование)

---

### Функция: print_canvas()
```c
void print_canvas(char canvas[CANVAS_HEIGHT][CANVAS_WIDTH])
```
**Назначение:** Вывод холста на экран

**Логика работы:**
1. Внешний цикл по строкам
2. Внутренний цикл по столбцам
   - Выводит каждый символ
3. После каждой строки выводит перенос строки '\n'

---

## Модуль parser.c/h - Парсер и вычисления

### Структуры данных

```c
typedef enum {
    TOKEN_NUMBER,        // Число
    TOKEN_VARIABLE,      // Переменная x
    TOKEN_OPERATOR,      // Оператор +, -, *, /, ^
    TOKEN_FUNCTION,      // Функция sin, cos, etc.
    TOKEN_LEFT_PAREN,    // Левая скобка (
    TOKEN_RIGHT_PAREN    // Правая скобка )
} TokenType;

typedef struct {
    TokenType type;      // Тип токена
    char value[32];      // Строковое значение
    double numeric_value; // Числовое значение (для чисел)
} Token;

typedef struct {
    Token* tokens;       // Массив токенов
    int count;           // Количество токенов
    int capacity;        // Вместимость массива
} TokenList;
```

---

### Функция: create_token_list()
```c
TokenList* create_token_list(void)
```
**Назначение:** Создание пустого списка токенов

**Логика работы:**
1. Выделяет память под TokenList
2. Устанавливает начальную capacity = 10
3. count = 0
4. Выделяет память под массив из 10 токенов
5. Возвращает указатель на список

---

### Функция: add_token()
```c
void add_token(TokenList* list, Token token)
```
**Назначение:** Добавление токена в список

**Логика работы:**
1. Проверяет, заполнен ли массив (count >= capacity)
2. Если заполнен:
   - Удваивает capacity
   - Перевыделяет память для массива (realloc)
3. Добавляет токен в конец массива
4. Увеличивает count

**Динамическое расширение:** Обеспечивает эффективное использование памяти

---

### Функция: is_operator()
```c
int is_operator(char c)
```
**Назначение:** Проверка, является ли символ оператором

**Параметры:**
- `c` - проверяемый символ

**Логика:**
- Возвращает 1, если c один из: +, -, *, /, ^
- Возвращает 0 в противном случае

---

### Функция: is_function()
```c
int is_function(const char* str)
```
**Назначение:** Проверка, является ли строка допустимой функцией

**Параметры:**
- `str` - проверяемая строка

**Логика:**
- Возвращает 1, если str одно из: "sin", "cos", "tan", "ctg", "sqrt", "ln"
- Возвращает 0 в противном случае

**Поддерживаемые функции:**
- sin(x) - синус
- cos(x) - косинус
- tan(x) - тангенс
- ctg(x) - котангенс (1/tan)
- sqrt(x) - квадратный корень
- ln(x) - натуральный логарифм

---

### Функция: get_precedence()
```c
int get_precedence(char op)
```
**Назначение:** Получение приоритета оператора

**Приоритеты:**
- `+`, `-` → приоритет 1 (самый низкий)
- `*`, `/` → приоритет 2 (средний)
- `^` → приоритет 3 (самый высокий)

**Использование:** Для алгоритма Shunting Yard

---

### Функция: tokenize()
```c
TokenList* tokenize(const char* input)
```
**Назначение:** Разбор входной строки на токены (лексический анализ)

**Параметры:**
- `input` - строка с математическим выражением

**Логика работы (подробно):**

1. **Инициализация:**
   - Создает пустой список токенов
   - Получает длину входной строки
   - Инициализирует индекс i = 0

2. **Основной цикл** (пока i < len и нет ошибок):

   **a) Пропуск пробелов:**
   ```
   Если input[i] - пробел → i++
   ```

   **b) Распознавание числа:**
   ```
   Если цифра или точка с последующей цифрой:
   - Считывает все цифры и точки в строку num
   - Создает TOKEN_NUMBER
   - Конвертирует в double (atof)
   - Добавляет в список
   ```

   **c) Распознавание переменной:**
   ```
   Если символ 'x':
   - Создает TOKEN_VARIABLE
   - value = "x"
   - Добавляет в список
   ```

   **d) Распознавание функции:**
   ```
   Если буква (не 'x'):
   - Считывает последовательность букв
   - Создает TOKEN_FUNCTION
   - Сохраняет имя функции
   - Добавляет в список
   ```

   **e) Распознавание оператора:**
   ```
   Если +, -, *, /, ^:
   - Создает TOKEN_OPERATOR
   - Сохраняет символ
   - Добавляет в список
   ```

   **f) Распознавание скобок:**
   ```
   Если '(' → TOKEN_LEFT_PAREN
   Если ')' → TOKEN_RIGHT_PAREN
   ```

   **g) Обработка ошибки:**
   ```
   Если неизвестный символ:
   - Устанавливает error = 1
   - Освобождает память
   - Возвращает NULL
   ```

**Возвращает:** 
- Указатель на TokenList при успехе
- NULL при ошибке

**Примеры токенизации:**
```
Вход: "sin(x)"
Выход: [TOKEN_FUNCTION:"sin", TOKEN_LEFT_PAREN, TOKEN_VARIABLE:"x", TOKEN_RIGHT_PAREN]

Вход: "2*x+3"
Выход: [TOKEN_NUMBER:2, TOKEN_OPERATOR:*, TOKEN_VARIABLE:x, TOKEN_OPERATOR:+, TOKEN_NUMBER:3]

Вход: "x^2.5"
Выход: [TOKEN_VARIABLE:x, TOKEN_OPERATOR:^, TOKEN_NUMBER:2.5]
```

---

### Функция: validate_expression()
```c
int validate_expression(TokenList* tokens)
```
**Назначение:** Валидация синтаксиса выражения

**Проверки:**

1. **Баланс скобок:**
   - Счетчик paren_count начинается с 0
   - При '(' → paren_count++
   - При ')' → paren_count--
   - Если paren_count < 0 → ошибка (закрывающая скобка без открывающей)
   - В конце должен быть paren_count == 0

2. **Валидность функций:**
   - Для каждой функции проверяет через is_function()
   - Неизвестная функция → ошибка

**Возвращает:**
- 1 - выражение валидно
- 0 - есть ошибки

**Примеры:**
```
"(x+2))" → invalid (лишняя закрывающая скобка)
"((x+2)" → invalid (нет закрывающей скобки)
"sinh(x)" → invalid (неизвестная функция)
"sin(x)+cos(x)" → valid
```

---

### Функция: shunting_yard()
```c
TokenList* shunting_yard(TokenList* tokens)
```
**Назначение:** Преобразование инфиксной нотации в обратную польскую нотацию (RPN)

**Алгоритм Дейкстры "Сортировочная станция":**

**Инициализация:**
- Создает выходной список (output)
- Создает операторный стек (stack)

**Основной цикл** (для каждого токена):

1. **TOKEN_NUMBER или TOKEN_VARIABLE:**
   ```
   → Сразу добавляется в output
   ```

2. **TOKEN_FUNCTION:**
   ```
   → Помещается в stack
   ```

3. **TOKEN_OPERATOR:**
   ```
   Пока на вершине stack есть оператор с приоритетом >= текущего:
   - Извлечь его из stack
   - Добавить в output
   Затем поместить текущий оператор в stack
   ```

4. **TOKEN_LEFT_PAREN:**
   ```
   → Помещается в stack
   ```

5. **TOKEN_RIGHT_PAREN:**
   ```
   Извлекаем операторы из stack в output, пока не найдем '(':
   - Если '(' найдена → удаляем её (не добавляем в output)
   - Если '(' не найдена → ошибка
   ```

**Финализация:**
```
После обработки всех токенов:
- Извлекаем все оставшиеся операторы из stack в output
- Если встретили '(' → ошибка (несбалансированные скобки)
```

**Примеры преобразования:**
```
Инфикс: 2 + 3 * 4
RPN: 2 3 4 * +

Инфикс: (2 + 3) * 4
RPN: 2 3 + 4 *

Инфикс: sin(x) + cos(x)
RPN: x sin x cos +

Инфикс: x^2 + 2*x + 1
RPN: x 2 ^ 2 x * + 1 +
```

**Возвращает:**
- Указатель на TokenList с RPN
- NULL при ошибке

---

### Функция: eval_rpn()
```c
double eval_rpn(TokenList* rpn_tokens, double x)
```
**Назначение:** Вычисление значения выражения в RPN для заданного x

**Параметры:**
- `rpn_tokens` - список токенов в обратной польской нотации
- `x` - значение переменной x

**Алгоритм вычисления:**

**Инициализация:**
- Создает стек для чисел (Stack)
- result = 0.0

**Основной цикл** (для каждого токена):

1. **TOKEN_NUMBER:**
   ```
   - Выделяет память для double
   - Копирует numeric_value токена
   - Помещает в стек
   ```

2. **TOKEN_VARIABLE:**
   ```
   - Выделяет память для double
   - Копирует значение параметра x
   - Помещает в стек
   ```

3. **TOKEN_OPERATOR (бинарные операции):**
   ```
   - Извлекает два операнда из стека (b, затем a)
   - Выполняет операцию:
     '+' → a + b
     '-' → a - b
     '*' → a * b
     '/' → a / b
     '^' → pow(a, b)
   - Результат помещает обратно в стек
   - Освобождает память a и b
   ```

4. **TOKEN_FUNCTION (унарные функции):**
   ```
   - Извлекает один операнд из стека (a)
   - Применяет функцию:
     "sin" → sin(a)
     "cos" → cos(a)
     "tan" → tan(a)
     "ctg" → 1.0 / tan(a)
     "sqrt" → sqrt(a)
     "ln" → log(a)
   - Результат помещает обратно в стек
   - Освобождает память a
   ```

**Финализация:**
```
- Извлекает финальный результат из стека
- Очищает стек (освобождает оставшиеся элементы)
- Освобождает стек
- Возвращает результат
```

**Пример вычисления:**
```
RPN: 2 3 4 * +
x = 0 (не используется)

Шаг 1: Токен "2" → стек: [2]
Шаг 2: Токен "3" → стек: [2, 3]
Шаг 3: Токен "4" → стек: [2, 3, 4]
Шаг 4: Токен "*" → pop 4, pop 3 → 3*4=12 → стек: [2, 12]
Шаг 5: Токен "+" → pop 12, pop 2 → 2+12=14 → стек: [14]
Результат: 14
```

```
RPN: x 2 ^
x = 3

Шаг 1: Токен "x" → стек: [3]
Шаг 2: Токен "2" → стек: [3, 2]
Шаг 3: Токен "^" → pop 2, pop 3 → 3^2=9 → стек: [9]
Результат: 9
```

**Возвращает:** Вычисленное значение (double)

---

### Функция: free_token_list()
```c
void free_token_list(TokenList* list)
```
**Назначение:** Освобождение памяти списка токенов

**Логика:**
1. Освобождает массив tokens
2. Освобождает структуру TokenList

---

## Модуль graph.c - Главная программа

### Функция: main()
```c
int main(void)
```
**Назначение:** Координация всего процесса построения графика

**Детальная логика работы:**

---

#### ШАГ 1: Инициализация
```c
char input[256];      // Буфер для ввода
int success = 0;      // Флаг успешности
```

---

#### ШАГ 2: Чтение входных данных
```c
if (fgets(input, sizeof(input), stdin) != NULL) {
    // Удаление символа новой строки
    int len = strlen(input);
    if (len > 0 && input[len - 1] == '\n') {
        input[len - 1] = '\0';
    }
```

**Действия:**
- Читает строку из stdin (до 255 символов)
- Удаляет символ '\n' в конце, если есть

---

#### ШАГ 3: Токенизация
```c
TokenList* tokens = tokenize(input);
if (tokens != NULL) {
```

**Вызов:** `tokenize(input)`
**Результат:** Список токенов или NULL при ошибке

---

#### ШАГ 4: Валидация
```c
if (validate_expression(tokens)) {
```

**Вызов:** `validate_expression(tokens)`
**Проверяет:** Синтаксическую корректность

---

#### ШАГ 5: Преобразование в RPN
```c
TokenList* rpn_tokens = shunting_yard(tokens);
if (rpn_tokens != NULL) {
```

**Вызов:** `shunting_yard(tokens)`
**Результат:** RPN-представление или NULL при ошибке

---

#### ШАГ 6: Инициализация холста
```c
char canvas[25][80];
init_canvas(canvas);
```

**Вызов:** `init_canvas(canvas)`
**Действие:** Заполняет массив точками '.'

---

#### ШАГ 7: Построение графика
```c
int screen_x;
for (screen_x = 0; screen_x < 80; screen_x++) {
    // Преобразование экранной координаты в математическую
    double math_x = (screen_x * 4 * M_PI) / 79.0;
    
    // Вычисление значения функции
    double math_y = eval_rpn(rpn_tokens, math_x);
    
    // Проверка попадания в область значений
    if (math_y >= -1.0 && math_y <= 1.0) {
        // Преобразование в экранную координату
        int screen_y = 12 - (int)round(math_y * 12.0);
        
        // Проверка границ
        if (screen_y >= 0 && screen_y < 25) {
            canvas[screen_y][screen_x] = '*';
        }
    }
}
```

**Детальное объяснение:**

**а) Область определения: [0, 4π]**
```
screen_x изменяется от 0 до 79 (80 точек)
math_x = screen_x * 4π / 79
```
- При screen_x = 0 → math_x = 0
- При screen_x = 79 → math_x = 4π

**б) Вычисление функции:**
```
math_y = eval_rpn(rpn_tokens, math_x)
```
- Вызывает вычисление для текущего math_x

**в) Область значений: [-1, 1]**
```
if (math_y >= -1.0 && math_y <= 1.0)
```
- Значения вне диапазона игнорируются

**г) Преобразование Y-координаты:**
```
screen_y = 12 - (int)round(math_y * 12.0)
```

**Математика преобразования:**
- Центр координат: строка 12
- math_y = 0 → screen_y = 12 (центр)
- math_y = 1 → screen_y = 12 - 12 = 0 (верх)
- math_y = -1 → screen_y = 12 + 12 = 24 (низ)
- round() округляет до ближайшего целого

**д) Отрисовка точки:**
```
canvas[screen_y][screen_x] = '*'
```

---

#### ШАГ 8: Вывод графика
```c
print_canvas(canvas);
```

**Вызов:** `print_canvas(canvas)`
**Действие:** Выводит 25 строк по 80 символов

---

#### ШАГ 9: Очистка памяти
```c
free_token_list(rpn_tokens);
success = 1;
```

---

#### ШАГ 10: Обработка ошибок
```c
if (!success) {
    printf("n/a\n");
}
```

**Вывод "n/a" если:**
- Ошибка токенизации
- Невалидное выражение
- Ошибка преобразования в RPN

---

## Поток выполнения программы

### Полная цепочка вызовов для примера "sin(x)"

```
1. main()
   ↓
2. fgets() → читаем "sin(x)"
   ↓
3. tokenize("sin(x)")
   ├→ create_token_list()
   ├→ add_token() × 4 раза
   │  [sin, (, x, )]
   ↓
4. validate_expression(tokens)
   ├→ is_function("sin") → 1
   ├→ Проверка скобок: OK
   ↓
5. shunting_yard(tokens)
   ├→ create_token_list() для output
   ├→ create_stack() для операторов
   │
   │  Обработка токенов:
   ├→ "sin" → push в stack
   ├→ "(" → push в stack
   ├→ "x" → в output
   ├→ ")" → pop до "(" → "sin" в output
   │
   ├→ Результат: [x, sin]
   ↓
6. init_canvas(canvas)
   ├→ Заполнение массива точками
   ↓
7. ЦИКЛ по screen_x от 0 до 79:
   │
   ├→ screen_x = 0:
   │  ├→ math_x = 0
   │  ├→ eval_rpn([x, sin], 0)
   │  │  ├→ create_stack()
   │  │  ├→ Токен "x" → push(0)
   │  │  ├→ Токен "sin" → pop(0) → sin(0) = 0 → push(0)
   │  │  ├→ Результат: 0
   │  ├→ math_y = 0
   │  ├→ screen_y = 12 - 0 = 12
   │  ├→ canvas[12][0] = '*'
   │
   ├→ screen_x = 20:
   │  ├→ math_x ≈ π
   │  ├→ eval_rpn([x, sin], π)
   │  │  ├→ sin(π) ≈ 0
   │  ├→ canvas[12][20] = '*'
   │
   ├→ screen_x = 40:
   │  ├→ math_x ≈ 2π
   │  ├→ eval_rpn([x, sin], 2π)
   │  │  ├→ sin(2π) ≈ 0
   │  ├→ canvas[12][40] = '*'
   │
   └→ ... и так далее для всех 80 точек
   ↓
8. print_canvas(canvas)
   ├→ Вывод 25 строк × 80 символов
   ↓
9. free_token_list(rpn_tokens)
   free_token_list(tokens)
   ↓
10. return 0
```

---

### Пример для выражения "x^2"

```
Ввод: "x^2"
↓
Токенизация: [x, ^, 2]
↓
Валидация: OK
↓
RPN: [x, 2, ^]
↓
Вычисление для x=0:
  - push(0)
  - push(2)
  - pop(2), pop(0) → 0^2 = 0
  - Результат: 0 → screen_y = 12
↓
Вычисление для x=π:
  - push(π)
  - push(2)
  - pop(2), pop(π) → π^2 ≈ 9.87
  - math_y > 1 → не рисуем
↓
График: парабола, видимая только около x=0
```

---

### Пример для выражения "cos(2*x)"

```
Ввод: "cos(2*x)"
↓
Токенизация: [cos, (, 2, *, x, )]
↓
RPN: [2, x, *, cos]
↓
Вычисление для x=π/4:
  - push(2)
  - push(π/4)
  - pop(π/4), pop(2) → 2*(π/4) = π/2
  - pop(π/2) → cos(π/2) = 0
  - Результат: 0 → screen_y = 12
↓
Частота удвоенная по сравнению с cos(x)
```

---

## Особенности реализации

### 1. Структурное программирование
- Используются только while циклы (принцип Дейкстры)
- Отсутствует goto
- Один вход и один выход из функций
- Вложенность не более 4 уровней

### 2. Управление памятью
- Динамическое выделение:
  - TokenList (динамическое расширение)
  - Stack (связный список)
  - Числа в стеке вычислений
- Обязательная очистка:
  - free_token_list()
  - free_stack()
  - Освобождение каждого элемента стека

### 3. Обработка ошибок
- Проверка NULL после каждого malloc
- Флаг error для прекращения обработки
- Корректная очистка при ошибках
- Вывод "n/a" при любой ошибке

### 4. Координатная система
```
(0,0)  ────────────────────────→ X (79, 0)
  │
  │         Canvas 80×25
  │
  │    (0,12) = математический центр (x=0, y=0)
  │
  ↓
  Y
(0,24)                        (79, 24)
```

**Преобразования:**
- Экранная X → Математическая X: `math_x = screen_x * 4π / 79`
- Математическая Y → Экранная Y: `screen_y = 12 - round(math_y * 12)`

### 5. Точность вычислений
- Все вычисления в double
- Округление через round()
- Игнорирование значений вне [-1, 1]

---

## Проверка на принципы структурного программирования

✅ **Принцип 1:** Нет goto  
✅ **Принцип 2:** Только последовательность, ветвление, циклы  
✅ **Принцип 3:** Произвольная вложенность конструкций  
✅ **Принцип 4:** Логика разбита на функции  
✅ **Принцип 5:** Функции - логически завершенные блоки  
✅ **Принцип 6:** Один вход, один выход  
✅ **Принцип 7:** Модульная разработка  

**Дополнительно:**
✅ Нет глобальных переменных  
✅ Один выход из функций  
✅ Один выход из циклов  
✅ Вложенность ≤ 4  
✅ Функции ≤ 42 строки  
✅ Нет exit()  

---

## Резюме

Проект реализует полноценный калькулятор и построитель графиков:

1. **Парсинг** - преобразование текста в токены
2. **Валидация** - проверка корректности
3. **Преобразование** - инфикс → RPN (алгоритм Дейкстры)
4. **Вычисление** - стековая машина для RPN
5. **Визуализация** - построение графика в ASCII

Все модули независимы и переиспользуемы. Код следует принципам структурного программирования Дейкстры.
