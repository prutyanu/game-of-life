# Подробная документация проекта T09D15

## Оглавление
1. [Общее описание проекта](#общее-описание-проекта)
2. [Структура проекта](#структура-проекта)
3. [Правила и условия разработки](#правила-и-условия-разработки)
4. [Детальный разбор модулей](#детальный-разбор-модулей)
   - [4.1. Модуль data_libs](#41-модуль-data_libs)
   - [4.2. Модуль data_module](#42-модуль-data_module)
   - [4.3. Модуль yet_another_decision_module](#43-модуль-yet_another_decision_module)
   - [4.4. Модуль main_executable_module](#44-модуль-main_executable_module)
5. [Система сборки Makefile](#система-сборки-makefile)
6. [Взаимодействие модулей](#взаимодействие-модулей)
7. [Пошаговое выполнение программы](#пошаговое-выполнение-программы)

---

## Общее описание проекта

Это учебный проект по разработке многофайловых программ на языке C. Проект демонстрирует:
- Разделение кода на модули (отдельные файлы)
- Работу с заголовочными файлами (.h)
- Использование библиотек (статических .a и динамических .so)
- Автоматизацию сборки с помощью Makefile
- Работу с указателями и динамической памятью

**Цель проекта:** обработка массива чисел с плавающей точкой (double) - нормализация, сортировка и принятие решения на основе статистических данных.

---

## Структура проекта

```
T09D15.ID_239636-1-develop/
├── src/
│   ├── data_libs/              # Библиотечные модули (общие функции)
│   │   ├── data_io.h          # Заголовок: ввод/вывод данных
│   │   ├── data_io.c          # Реализация ввода/вывода
│   │   ├── data_stat.h        # Заголовок: статистические функции
│   │   └── data_stat.c        # Реализация статистики
│   │
│   ├── data_module/            # Модуль обработки данных
│   │   ├── data_module_entry.c    # Точка входа (главная программа)
│   │   ├── data_process.h     # Заголовок: функции обработки
│   │   └── data_process.c     # Реализация нормализации
│   │
│   ├── yet_another_decision_module/  # Модуль принятия решений
│   │   ├── yet_another_decision_module_entry.c  # Точка входа
│   │   ├── decision.h         # Заголовок: функции принятия решений
│   │   └── decision.c         # Реализация логики решений
│   │
│   └── main_executable_module/  # Главный исполняемый модуль
│       ├── main_executable_module.c  # Главная программа
│       ├── sort.h             # Заголовок: функции сортировки
│       ├── sort.c             # Реализация сортировки
│       └── Makefile           # Файл автоматизации сборки
│
├── build/                      # Папка для скомпилированных программ
├── README.md                   # Описание задания (англ.)
└── README_RUS.md              # Описание задания (рус.)
```

---

## Правила и условия разработки

### Ключевые требования из README:

1. **Модульность**: код разделен на отдельные файлы и модули, каждый модуль отвечает за свою задачу
2. **Повторное использование**: максимально используются существующие функции через директивы препроцессора (#include)
3. **Запрет системных вызовов**: нельзя использовать функцию system() и подобные
4. **Формат вывода**: все числа с плавающей точкой выводятся с точностью до 2 знаков после запятой
5. **Структура файлов**: нельзя менять разбивку на файлы (согласовано с архитектором)
6. **Результаты компиляции**: не загружаются в репозиторий (находятся в папке build/)

### Этапы выполнения проекта (Quests):

- **Quest 1**: Доработать модуль data_module
- **Quest 2**: Доработать модуль yet_another_decision_module
- **Quest 3**: Создать Makefile с целями clean, all, rebuild
- **Quest 4**: Добавить макроопределения для работы с разными типами данных
- **Quest 5**: Собрать data_stat как статическую библиотеку (.a)
- **Quest 6**: Собрать data_process как динамическую библиотеку (.so)

---

## Детальный разбор модулей

### 4.1. Модуль data_libs

Это библиотечный модуль, содержащий базовые функции для работы с данными. Он состоит из двух частей.

#### 4.1.1. Файл data_io.h (заголовочный файл ввода/вывода)

```c
#ifndef DATA_IO_H
#define DATA_IO_H

void input(double *data, int n);
void output(const double *data, int n);

#endif
```

**Разбор построчно:**

- **Строка 1: `#ifndef DATA_IO_H`**
  - Это защита от повторного включения (include guard)
  - Проверяет: "Если макрос DATA_IO_H еще НЕ определен, то..."
  - Нужна, чтобы избежать ошибок при многократном подключении файла

- **Строка 2: `#define DATA_IO_H`**
  - Определяет макрос DATA_IO_H
  - Если файл подключится второй раз, строка 1 пропустит его содержимое

- **Строка 4: `void input(double *data, int n);`**
  - Объявление (прототип) функции input
  - `void` - функция ничего не возвращает
  - `double *data` - параметр: указатель на массив чисел типа double
  - `int n` - параметр: количество элементов в массиве
  - Точка с запятой в конце означает, что это только объявление, а реализация в другом файле

- **Строка 5: `void output(const double *data, int n);`**
  - Объявление функции output для вывода данных
  - `const` перед `double *data` означает, что функция не будет изменять данные (только читать)

- **Строка 7: `#endif`**
  - Конец блока защиты от повторного включения

**Назначение файла**: описывает интерфейс для работы с вводом/выводом массивов чисел

---

#### 4.1.2. Файл data_io.c (реализация ввода/вывода)

```c
#include "data_io.h"

#include <stdio.h>

void input(double *data, int n) {
    for (int i = 0; i < n; i++) {
        scanf("%lf", &data[i]);
    }
}

void output(const double *data, int n) {
    for (int i = 0; i < n; i++) {
        if (i > 0) printf(" ");
        printf("%.2lf", data[i]);
    }
}
```

**Разбор построчно:**

- **Строка 1: `#include "data_io.h"`**
  - Подключает заголовочный файл data_io.h
  - Кавычки "" означают, что файл находится в той же директории
  - Препроцессор вставит сюда содержимое data_io.h

- **Строка 3: `#include <stdio.h>`**
  - Подключает стандартную библиотеку для ввода/вывода
  - Угловые скобки <> означают системный заголовочный файл
  - Нужна для функций scanf и printf

- **Строка 5-9: Функция input**
  ```c
  void input(double *data, int n) {
      for (int i = 0; i < n; i++) {
          scanf("%lf", &data[i]);
      }
  }
  ```
  - **Строка 5**: начало функции input
  - **Строка 6**: цикл for - повторяет действия n раз
    - `int i = 0` - создает переменную-счетчик i, начальное значение 0
    - `i < n` - условие продолжения цикла (пока i меньше n)
    - `i++` - увеличивает i на 1 после каждой итерации
  - **Строка 7**: `scanf("%lf", &data[i]);`
    - `scanf` - функция для чтения данных с клавиатуры
    - `"%lf"` - формат для чтения числа типа double (long float)
    - `&data[i]` - адрес i-го элемента массива
      - `data[i]` - обращение к i-му элементу массива
      - `&` - оператор взятия адреса (scanf нужен адрес, куда записать число)

**Как работает input:**
1. Функция получает указатель на массив и количество элементов
2. Запускает цикл от 0 до n-1
3. На каждой итерации считывает одно число и записывает его в массив

---

- **Строка 11-16: Функция output**
  ```c
  void output(const double *data, int n) {
      for (int i = 0; i < n; i++) {
          if (i > 0) printf(" ");
          printf("%.2lf", data[i]);
      }
  }
  ```
  - **Строка 11**: начало функции output
    - `const double *data` - указатель на константные данные (нельзя изменять)
  - **Строка 12**: цикл for для прохода по всем элементам
  - **Строка 13**: `if (i > 0) printf(" ");`
    - Проверка: если это не первый элемент (i > 0)
    - То выводит пробел перед числом (для разделения чисел)
    - Это гарантирует, что между числами будут пробелы, но не в начале
  - **Строка 14**: `printf("%.2lf", data[i]);`
    - `printf` - функция вывода на экран
    - `"%.2lf"` - формат вывода:
      - `%lf` - число типа double
      - `.2` - показывать 2 знака после запятой
    - `data[i]` - значение i-го элемента массива

**Как работает output:**
1. Проходит по всем элементам массива
2. Перед каждым элементом (кроме первого) выводит пробел
3. Выводит число с точностью 2 знака после запятой

**Пример работы:**
- Массив: [3.14159, 2.71828, 1.41421]
- Вывод: `3.14 2.72 1.41`

---

#### 4.1.3. Файл data_stat.h (заголовочный файл статистики)

```c
#ifndef DATA_STAT_H
#define DATA_STAT_H

double max(const double *data, int n);
double min(const double *data, int n);
double mean(const double *data, int n);
double variance(const double *data, int n);

#endif
```

**Разбор построчно:**

- **Строки 1-2**: защита от повторного включения (как в data_io.h)

- **Строка 4: `double max(const double *data, int n);`**
  - Объявление функции поиска максимального значения
  - `double` - функция возвращает число типа double
  - `max` - имя функции
  - Параметры: указатель на массив и размер

- **Строка 5: `double min(const double *data, int n);`**
  - Объявление функции поиска минимального значения

- **Строка 6: `double mean(const double *data, int n);`**
  - Объявление функции вычисления среднего значения
  - mean (англ.) - среднее арифметическое

- **Строка 7: `double variance(const double *data, int n);`**
  - Объявление функции вычисления дисперсии
  - variance (англ.) - дисперсия (мера разброса данных)

**Назначение файла**: описывает интерфейс статистических функций

---

#### 4.1.4. Файл data_stat.c (реализация статистики)

```c
#include "data_stat.h"

double max(const double *data, int n) {
    double max_value = data[0];
    for (int i = 1; i < n; i++) {
        if (data[i] > max_value) max_value = data[i];
    }
    return max_value;
}

double min(const double *data, int n) {
    double min_value = data[0];
    for (int i = 1; i < n; i++) {
        if (data[i] < min_value) min_value = data[i];
    }
    return min_value;
}

double mean(const double *data, int n) {
    double sum = 0.0;
    for (int i = 0; i < n; i++) {
        sum += data[i];
    }
    return sum / n;
}

double variance(const double *data, int n) {
    double mean_value = mean(data, n);
    double sum = 0.0;
    for (int i = 0; i < n; i++) {
        double diff = data[i] - mean_value;
        sum += diff * diff;
    }
    return sum / n;
}
```

**Разбор построчно:**

- **Строка 1**: подключает data_stat.h

**Функция max (строки 3-9):**
```c
double max(const double *data, int n) {
    double max_value = data[0];
    for (int i = 1; i < n; i++) {
        if (data[i] > max_value) max_value = data[i];
    }
    return max_value;
}
```

- **Строка 4**: `double max_value = data[0];`
  - Создает переменную max_value (максимальное значение)
  - Инициализирует её первым элементом массива
  - Предполагаем, что первый элемент - самый большой

- **Строка 5**: цикл начинается с i=1 (не с 0!), потому что data[0] уже проверен

- **Строка 6**: `if (data[i] > max_value) max_value = data[i];`
  - Проверяет: текущий элемент больше максимального?
  - Если да, обновляет max_value
  - Это однострочный if (без фигурных скобок)

- **Строка 8**: `return max_value;`
  - Возвращает найденное максимальное значение
  - Функция завершается и передает результат вызывающему коду

**Алгоритм работы max:**
1. Берем первый элемент как "предполагаемый максимум"
2. Проходим по остальным элементам
3. Если находим элемент больше текущего максимума - обновляем максимум
4. Возвращаем найденный максимум

**Пример:**
- Массив: [3.5, 7.2, 1.8, 9.1, 4.3]
- Шаги:
  - max_value = 3.5
  - 7.2 > 3.5 → max_value = 7.2
  - 1.8 < 7.2 → не меняем
  - 9.1 > 7.2 → max_value = 9.1
  - 4.3 < 9.1 → не меняем
  - Результат: 9.1

---

**Функция min (строки 11-17):**
```c
double min(const double *data, int n) {
    double min_value = data[0];
    for (int i = 1; i < n; i++) {
        if (data[i] < min_value) min_value = data[i];
    }
    return min_value;
}
```

- Работает аналогично max, но ищет минимум
- Отличие в строке 14: `if (data[i] < min_value)` - проверяет "меньше ли"

**Алгоритм работы min:**
1. Берем первый элемент как "предполагаемый минимум"
2. Проходим по остальным элементам
3. Если находим элемент меньше текущего минимума - обновляем минимум
4. Возвращаем найденный минимум

---

**Функция mean (строки 19-25):**
```c
double mean(const double *data, int n) {
    double sum = 0.0;
    for (int i = 0; i < n; i++) {
        sum += data[i];
    }
    return sum / n;
}
```

- **Строка 20**: `double sum = 0.0;`
  - Создает переменную для накопления суммы
  - Инициализируется нулем
  - `.0` указывает, что это число с плавающей точкой

- **Строки 21-23**: цикл суммирования
  - **Строка 22**: `sum += data[i];`
    - Оператор `+=` - сокращенная запись для `sum = sum + data[i]`
    - Прибавляет текущий элемент к сумме

- **Строка 24**: `return sum / n;`
  - Делит сумму на количество элементов
  - Это и есть среднее арифметическое

**Формула среднего арифметического:**
```
mean = (x₁ + x₂ + ... + xₙ) / n
```

**Пример:**
- Массив: [2.0, 4.0, 6.0, 8.0]
- sum = 2.0 + 4.0 + 6.0 + 8.0 = 20.0
- mean = 20.0 / 4 = 5.0

---

**Функция variance (строки 27-35):**
```c
double variance(const double *data, int n) {
    double mean_value = mean(data, n);
    double sum = 0.0;
    for (int i = 0; i < n; i++) {
        double diff = data[i] - mean_value;
        sum += diff * diff;
    }
    return sum / n;
}
```

- **Строка 28**: `double mean_value = mean(data, n);`
  - ВЫЗЫВАЕТ функцию mean (строка 19)
  - Сохраняет результат в переменную mean_value
  - Это пример повторного использования кода

- **Строка 29**: инициализирует sum нулем

- **Строки 30-33**: цикл вычисления дисперсии
  - **Строка 31**: `double diff = data[i] - mean_value;`
    - Вычисляет отклонение: разницу между элементом и средним
    - Сохраняет во временную переменную diff

  - **Строка 32**: `sum += diff * diff;`
    - Возводит отклонение в квадрат
    - `diff * diff` - квадрат отклонения
    - Прибавляет к сумме

- **Строка 34**: `return sum / n;`
  - Делит сумму квадратов на количество элементов
  - Это формула дисперсии

**Формула дисперсии:**
```
variance = Σ(xᵢ - mean)² / n
где Σ - сумма, xᵢ - элементы массива
```

**Что показывает дисперсия:**
- Насколько сильно числа отклоняются от среднего
- Маленькая дисперсия - числа близки к среднему
- Большая дисперсия - числа сильно разбросаны

**Пример:**
- Массив: [2.0, 4.0, 6.0, 8.0]
- mean_value = 5.0
- Отклонения: [-3.0, -1.0, 1.0, 3.0]
- Квадраты: [9.0, 1.0, 1.0, 9.0]
- sum = 20.0
- variance = 20.0 / 4 = 5.0

---

### 4.2. Модуль data_module

Этот модуль отвечает за обработку данных (нормализацию).

#### 4.2.1. Файл data_module_entry.c (точка входа)

```c
#include <stdio.h>
#include <stdlib.h>

#include "data_io.h"
#include "data_process.h"

int main(void) {
    double *data;
    int n;

    // Don`t forget to allocate memory !
    scanf("%d", &n);
    data = (double *)malloc(n * sizeof(double));

    if (data != NULL) {
        input(data, n);

        if (normalization(data, n))
            output(data, n);
        else
            printf("ERROR");

        free(data);
    }
    return 0;
}
```

**Разбор построчно:**

- **Строки 1-2**: подключение стандартных библиотек
  - `stdio.h` - для scanf, printf
  - `stdlib.h` - для malloc, free (работа с динамической памятью)

- **Строки 4-5**: подключение наших модулей
  - `data_io.h` - для функций input, output
  - `data_process.h` - для функции normalization

- **Строка 7**: `int main(void) {`
  - Главная функция программы
  - Точка входа - отсюда начинается выполнение
  - `int` - функция возвращает целое число (код завершения)
  - `void` - функция не принимает параметров

- **Строки 8-9**: объявление переменных
  - `double *data;` - указатель на массив чисел double
    - Символ `*` означает "указатель" (адрес в памяти)
    - Пока не выделена память, это "пустой" указатель
  - `int n;` - количество элементов

- **Строка 12**: `scanf("%d", &n);`
  - Считывает целое число (количество элементов)
  - `"%d"` - формат для целого числа (decimal)
  - Сохраняет в переменную n

- **Строка 13**: `data = (double *)malloc(n * sizeof(double));`
  - **КРИТИЧЕСКАЯ СТРОКА** - выделение динамической памяти
  - Разберем по частям:
    - `sizeof(double)` - размер одного элемента типа double в байтах
    - `n * sizeof(double)` - размер для n элементов
    - `malloc(...)` - функция выделения памяти
      - Запрашивает у операционной системы блок памяти
      - Возвращает адрес (указатель) на начало блока
      - Если памяти нет - возвращает NULL
    - `(double *)` - приведение типа
      - malloc возвращает void* (общий указатель)
      - Приводим к типу double* (указатель на double)
    - `data =` - сохраняем адрес в переменную data

**Что такое динамическая память:**
- Память, выделяемая во время работы программы (не заранее)
- Размер можно определять в процессе выполнения (зависит от n)
- Нужно вручную освобождать после использования

**Визуализация:**
```
До malloc:
data = ??? (неопределенный указатель)

После malloc при n=5:
data → [____][____][____][____][____]  (5 ячеек по 8 байт каждая)
       адрес памяти в оперативной памяти компьютера
```

---

- **Строка 15**: `if (data != NULL) {`
  - Проверка: удалось ли выделить память?
  - `NULL` - специальное значение "пустой указатель"
  - Если malloc вернул NULL - памяти не хватило
  - `!=` - оператор "не равно"

- **Строка 16**: `input(data, n);`
  - ВЫЗОВ функции input из модуля data_io
  - Передает указатель на массив и размер
  - Функция считает n чисел с клавиатуры

- **Строка 18**: `if (normalization(data, n))`
  - ВЫЗОВ функции normalization из модуля data_process
  - Функция нормализует данные (изменяет массив)
  - Возвращает 1 (успех) или 0 (ошибка)
  - Если вернула не 0 (true), выполняется строка 19

- **Строка 19**: `output(data, n);`
  - ВЫЗОВ функции output из модуля data_io
  - Выводит нормализованные данные

- **Строки 20-21**: блок else
  - Выполняется, если normalization вернула 0
  - Выводит сообщение об ошибке

- **Строка 23**: `free(data);`
  - **КРИТИЧЕСКАЯ СТРОКА** - освобождение памяти
  - Возвращает память операционной системе
  - Если не вызвать free - будет утечка памяти
  - Память освобождается, но data все еще хранит старый адрес
  - После free нельзя обращаться к data

- **Строка 25**: `return 0;`
  - Завершение программы с кодом 0
  - 0 означает успешное выполнение
  - Этот код возвращается операционной системе

**Жизненный цикл данных:**
```
1. Объявление указателя: double *data;
2. Выделение памяти: malloc → data указывает на память
3. Использование: input, normalization, output
4. Освобождение: free → память возвращена системе
5. Завершение программы
```

**Почему важна проверка data != NULL:**
- Если памяти недостаточно, программа не упадет с ошибкой
- Блок кода просто пропустится
- Это хороший стиль программирования (обработка ошибок)

---

#### 4.2.2. Файл data_process.h (заголовочный файл обработки)

```c
#ifndef PROCESSING_H
#define PROCESSING_H

#include "data_stat.h"

#define EPS 1E-6

int normalization(double *data, int n);

#endif
```

**Разбор построчно:**

- **Строки 1-2**: защита от повторного включения

- **Строка 4**: `#include "data_stat.h"`
  - Подключает модуль статистики
  - normalization использует функции max и min

- **Строка 6**: `#define EPS 1E-6`
  - Определение макроса (константы)
  - `#define` - директива препроцессора
  - `EPS` - имя константы (epsilon, эпсилон)
  - `1E-6` - научная нотация для 0.000001
  - Используется для сравнения чисел с плавающей точкой

**Зачем нужен EPS:**
- Числа с плавающей точкой неточны из-за ограничений представления
- Вместо проверки `x == 0` используют `|x| < EPS`
- EPS - малое число, порог для сравнения

- **Строка 8**: объявление функции normalization
  - Принимает массив и размер
  - Возвращает int (1 - успех, 0 - ошибка)

---

#### 4.2.3. Файл data_process.c (реализация нормализации)

```c
#include "data_process.h"

#include <math.h>

int normalization(double *data, int n) {
    int result = 1;
    double max_value = max(data, n);
    double min_value = min(data, n);
    double size = max_value - min_value;

    if (fabs(size) >= EPS) {
        for (int i = 0; i < n; i++) {
            data[i] = data[i] / size - min_value / size;
        }
    } else {
        result = 0;
    }

    return result;
}
```

**Разбор построчно:**

- **Строка 1**: подключает data_process.h

- **Строка 3**: `#include <math.h>`
  - Математическая библиотека
  - Нужна для функции fabs (модуль числа)

- **Строка 5**: `int normalization(double *data, int n) {`
  - Начало функции нормализации

- **Строка 6**: `int result = 1;`
  - Переменная для результата
  - Инициализируется 1 (предполагаем успех)

- **Строка 7**: `double max_value = max(data, n);`
  - ВЫЗЫВАЕТ функцию max из data_stat
  - Находит максимальный элемент массива
  - Сохраняет в max_value

- **Строка 8**: `double min_value = min(data, n);`
  - ВЫЗЫВАЕТ функцию min из data_stat
  - Находит минимальный элемент

- **Строка 9**: `double size = max_value - min_value;`
  - Вычисляет диапазон (размах) данных
  - size - это разница между максимумом и минимумом

- **Строка 11**: `if (fabs(size) >= EPS) {`
  - Проверка: диапазон достаточно большой?
  - `fabs(size)` - модуль (абсолютное значение) size
  - Сравнивает с EPS (0.000001)
  - Если size очень маленький - все числа почти одинаковы, нормализовать нельзя

**Зачем fabs:**
- size теоретически всегда >= 0 (max >= min)
- fabs добавлена для надежности (на случай ошибок округления)

---

- **Строки 12-14**: блок нормализации
  ```c
  for (int i = 0; i < n; i++) {
      data[i] = data[i] / size - min_value / size;
  }
  ```

  - **Строка 13**: **КЛЮЧЕВАЯ ФОРМУЛА НОРМАЛИЗАЦИИ**
    - Разберем по частям:
      - `data[i] / size` - делим элемент на диапазон
      - `min_value / size` - делим минимум на диапазон
      - Результат: `(data[i] - min_value) / size`
    - Эта формула преобразует данные в диапазон [0, 1]

**Формула нормализации:**
```
normalized = (x - min) / (max - min)
```

**Математический смысл:**
1. Вычитаем минимум: сдвигаем диапазон, чтобы начинался с 0
2. Делим на размах: масштабируем до диапазона [0, 1]

**Пример нормализации:**
```
Исходные данные: [10, 20, 30, 40, 50]
min = 10, max = 50, size = 40

Для 10: (10-10)/40 = 0/40 = 0.00
Для 20: (20-10)/40 = 10/40 = 0.25
Для 30: (30-10)/40 = 20/40 = 0.50
Для 40: (40-10)/40 = 30/40 = 0.75
Для 50: (50-10)/40 = 40/40 = 1.00

Нормализованные данные: [0.00, 0.25, 0.50, 0.75, 1.00]
```

**Важно:** функция ИЗМЕНЯЕТ исходный массив (не создает новый)

---

- **Строки 15-17**: блок else (если size < EPS)
  ```c
  } else {
      result = 0;
  }
  ```
  - Если диапазон слишком мал (все числа почти равны)
  - Устанавливает result = 0 (ошибка)
  - Массив не изменяется

**Почему нельзя нормализовать, если size мал:**
- Если все числа равны (например [5.0, 5.0, 5.0])
- То size = 0, и будет деление на ноль
- Это приведет к ошибке или бесконечности

- **Строка 19**: `return result;`
  - Возвращает 1 (успех) или 0 (ошибка)

---

### 4.3. Модуль yet_another_decision_module

Этот модуль принимает решение на основе статистических критериев.

#### 4.3.1. Файл yet_another_decision_module_entry.c

```c
#include <stdio.h>
#include <stdlib.h>

#include "data_io.h"
#include "decision.h"

int main(void) {
    double *data;
    int n;

    scanf("%d", &n);
    data = (double *)malloc(n * sizeof(double));

    if (data != NULL) {
        input(data, n);

        if (make_decision(data, n))
            printf("YES");
        else
            printf("NO");

        free(data);
    }

    return 0;
}
```

**Разбор построчно:**

Структура аналогична data_module_entry.c:

- **Строки 1-5**: подключение библиотек и модулей
- **Строки 7-9**: объявление переменных
- **Строка 11**: считывание количества элементов
- **Строка 12**: выделение памяти
- **Строка 14**: проверка успешности выделения
- **Строка 15**: ввод данных

- **Строка 17**: `if (make_decision(data, n))`
  - ВЫЗОВ функции make_decision из модуля decision
  - Функция анализирует данные
  - Возвращает 1 (YES) или 0 (NO)

- **Строки 18-20**: вывод результата
  - Если функция вернула истину - выводит "YES"
  - Иначе - "NO"

- **Строка 22**: освобождение памяти
- **Строка 25**: завершение программы

**Отличия от data_module_entry:**
- Не нормализует данные
- Не выводит сами данные
- Только принимает бинарное решение: YES/NO

---

#### 4.3.2. Файл decision.h

```c
#ifndef DECISION_H
#define DECISION_H

#include "data_stat.h"

#define GOLDEN_RATIO 0.666

int make_decision(double *data, int n);

#endif
```

**Разбор построчно:**

- **Строки 1-2**: защита от повторного включения

- **Строка 4**: подключает data_stat.h
  - Нужны функции: mean, variance, max

- **Строка 6**: `#define GOLDEN_RATIO 0.666`
  - Определение константы "золотое сечение"
  - Значение 0.666 (≈ 2/3)
  - Используется как порог для принятия решения

**Примечание:** классическое золотое сечение ≈ 1.618, но здесь используется другое значение

- **Строка 8**: объявление функции make_decision

---

#### 4.3.3. Файл decision.c

```c
#include "decision.h"

#include <math.h>

int make_decision(double *data, int n) {
    int decision = 1;

    double m = mean(data, n);
    double sigma = sqrt(variance(data, n));
    double max_value = max(data, n);
    // double min_value = min(data, n);

    decision &= (max_value <= m + 3 * sigma) && (max_value >= m - 3 * sigma) && (m >= GOLDEN_RATIO);

    return decision;
}
```

**Разбор построчно:**

- **Строка 1**: подключает decision.h
- **Строка 3**: подключает math.h для функции sqrt

- **Строка 5**: `int make_decision(double *data, int n) {`
  - Начало функции принятия решения

- **Строка 6**: `int decision = 1;`
  - Переменная для результата
  - Инициализируется 1 (предполагаем "YES")

- **Строка 8**: `double m = mean(data, n);`
  - ВЫЗЫВАЕТ функцию mean из data_stat
  - Вычисляет среднее арифметическое
  - Сохраняет в переменную m

- **Строка 9**: `double sigma = sqrt(variance(data, n));`
  - Вычисляет стандартное отклонение (сигму)
  - Разберем по частям:
    - `variance(data, n)` - вызов функции, возвращает дисперсию
    - `sqrt(...)` - квадратный корень (square root)
    - Стандартное отклонение = √дисперсия

**Что такое стандартное отклонение:**
- Мера разброса данных (как дисперсия)
- Показывает типичное отклонение от среднего
- Имеет ту же размерность, что и данные

- **Строка 10**: `double max_value = max(data, n);`
  - Находит максимальный элемент

- **Строка 11**: `// double min_value = min(data, n);`
  - Закомментированная строка
  - `//` - однострочный комментарий
  - Эта строка не выполняется (возможно, планировалась для будущего использования)

---

- **Строка 13**: **КЛЮЧЕВАЯ СТРОКА - логика принятия решения**
  ```c
  decision &= (max_value <= m + 3 * sigma) && (max_value >= m - 3 * sigma) && (m >= GOLDEN_RATIO);
  ```

**Разберем по частям:**

1. **Оператор `&=`**
   - Побитовое И с присваиванием
   - `decision &= X` эквивалентно `decision = decision & X`
   - Если X ложно (0), то decision станет 0
   - Если X истинно (не 0), decision не изменится

2. **Условие 1: `max_value <= m + 3 * sigma`**
   - Проверяет: максимум не превышает "верхнюю границу"
   - `m + 3 * sigma` - среднее + 3 стандартных отклонения
   - Это правило "трех сигм" (99.7% данных в норме попадают в этот диапазон)

3. **Оператор `&&`**
   - Логическое И (AND)
   - Результат истинен, только если ОБА условия истинны

4. **Условие 2: `max_value >= m - 3 * sigma`**
   - Проверяет: максимум не ниже "нижней границы"
   - `m - 3 * sigma` - среднее - 3 стандартных отклонения

**Условия 1 и 2 вместе:**
```
m - 3σ <= max_value <= m + 3σ
```
Проверяют, что максимум находится в пределах ±3σ от среднего

5. **Условие 3: `m >= GOLDEN_RATIO`**
   - Проверяет: среднее значение >= 0.666

**Итоговая логика:**
Решение положительное (YES), если:
1. Максимум в пределах 3 сигм от среднего
2. Среднее значение >= 0.666

**Статистический смысл:**
- Правило трех сигм - проверка на выбросы (outliers)
- Если максимум очень далеко от среднего - данные аномальны
- Порог GOLDEN_RATIO - дополнительное условие на "качество" данных

---

**Пример работы:**
```
Данные: [0.8, 0.9, 0.85, 0.88, 0.92]

Вычисления:
m = (0.8 + 0.9 + 0.85 + 0.88 + 0.92) / 5 = 0.87
variance = ... (сложно считать вручную)
sigma ≈ 0.04 (примерно)

Проверки:
1. max_value = 0.92
2. m + 3σ = 0.87 + 0.12 = 0.99
3. m - 3σ = 0.87 - 0.12 = 0.75
4. 0.75 <= 0.92 <= 0.99 ✓ (истина)
5. 0.87 >= 0.666 ✓ (истина)

Результат: decision = 1 (YES)
```

- **Строка 15**: `return decision;`
  - Возвращает 1 (YES) или 0 (NO)

---

### 4.4. Модуль main_executable_module

Главный исполняемый модуль, объединяющий все функции.

#### 4.4.1. Файл main_executable_module.c

```c
#include <stdio.h>
#include <stdlib.h>

#include "data_io.h"
#include "decision.h"
#include "sort.h"

#ifdef USE_DYNAMIC
#include <dlfcn.h>
#else
#include "data_process.h"
#endif

int main(void) {
    double *data;
    int n;

#ifdef USE_DYNAMIC
    void *lib_handle;
    int (*normalization)(double *, int);
    const char *error;

    lib_handle = dlopen("../data_module/data_process.so", RTLD_LAZY);
    if (!lib_handle) {
        fprintf(stderr, "%s\n", dlerror());
        return 1;
    }

    normalization = dlsym(lib_handle, "normalization");
    error = dlerror();
    if (error != NULL) {
        fprintf(stderr, "%s\n", error);
        dlclose(lib_handle);
        return 1;
    }
#endif

    printf("LOAD DATA...\n");
    scanf("%d", &n);
    data = (double *)malloc(n * sizeof(double));

    if (data != NULL) {
        input(data, n);

        printf("RAW DATA:\n\t");
        output(data, n);

        printf("\nNORMALIZED DATA:\n\t");
        if (normalization(data, n)) {
            output(data, n);
        }

        printf("\nSORTED NORMALIZED DATA:\n\t");
        sort(data, n);
        output(data, n);

        printf("\nFINAL DECISION:\n\t");
        if (make_decision(data, n)) {
            printf("YES");
        } else {
            printf("NO");
        }

        free(data);
    }

#ifdef USE_DYNAMIC
    dlclose(lib_handle);
#endif

    return 0;
}
```

**Разбор построчно:**

- **Строки 1-6**: подключение модулей
  - `data_io.h` - ввод/вывод
  - `decision.h` - принятие решений
  - `sort.h` - сортировка

**Блок условной компиляции (строки 8-12):**
```c
#ifdef USE_DYNAMIC
#include <dlfcn.h>
#else
#include "data_process.h"
#endif
```

- **`#ifdef USE_DYNAMIC`**
  - Директива препроцессора: "если определен макрос USE_DYNAMIC"
  - Проверяет, определен ли макрос USE_DYNAMIC (при компиляции)

- **Строка 9: `#include <dlfcn.h>`**
  - Подключается ТОЛЬКО если USE_DYNAMIC определен
  - dlfcn.h - библиотека для работы с динамическими библиотеками
  - dl = dynamic linking (динамическое связывание)

- **`#else`**
  - Иначе (если USE_DYNAMIC не определен)

- **Строка 11: `#include "data_process.h"`**
  - Подключается, если USE_DYNAMIC НЕ определен
  - Стандартный статический вариант

**Зачем это нужно:**
- Программа может работать в двух режимах:
  1. Статический: функции скомпилированы в программу
  2. Динамический: функции загружаются из .so файла во время выполнения
- Выбор режима происходит при компиляции (через флаг -DUSE_DYNAMIC)

---

- **Строки 14-16**: начало main и объявление переменных

**Блок динамической загрузки (строки 18-36):**
```c
#ifdef USE_DYNAMIC
    void *lib_handle;
    int (*normalization)(double *, int);
    const char *error;
```

- **Строка 19: `void *lib_handle;`**
  - Указатель на библиотеку
  - `void *` - общий тип указателя
  - Будет хранить "дескриптор" (handle) загруженной библиотеки

- **Строка 20: `int (*normalization)(double *, int);`**
  - **УКАЗАТЕЛЬ НА ФУНКЦИЮ** - сложная конструкция
  - Разберем:
    - `int (...)` - функция возвращает int
    - `(*normalization)` - указатель с именем normalization
    - `(double *, int)` - параметры функции
  - Это переменная, которая будет указывать на функцию normalization из библиотеки

**Что такое указатель на функцию:**
- Функция хранится в памяти по определенному адресу
- Указатель на функцию хранит этот адрес
- Можно вызывать функцию через указатель: `normalization(data, n)`

- **Строка 21**: `const char *error;`
  - Указатель на строку (сообщение об ошибке)

---

- **Строка 23: `lib_handle = dlopen("../data_module/data_process.so", RTLD_LAZY);`**
  - **Загрузка динамической библиотеки**
  - `dlopen` - функция открытия библиотеки
  - `"../data_module/data_process.so"` - путь к файлу библиотеки
    - `..` - родительская директория
    - `.so` - расширение для динамических библиотек в Linux
  - `RTLD_LAZY` - режим загрузки: "ленивый"
    - Символы (функции) разрешаются при первом использовании
    - Противоположность: RTLD_NOW (сразу все)
  - Возвращает handle (дескриптор) или NULL при ошибке

- **Строки 24-27**: проверка ошибки загрузки
  ```c
  if (!lib_handle) {
      fprintf(stderr, "%s\n", dlerror());
      return 1;
  }
  ```
  - `!lib_handle` - если NULL (загрузка не удалась)
  - `fprintf(stderr, ...)` - вывод в поток ошибок
    - `stderr` - стандартный поток ошибок (отличается от stdout)
  - `dlerror()` - возвращает текст последней ошибки
  - `return 1` - завершает программу с кодом ошибки

---

- **Строка 29: `normalization = dlsym(lib_handle, "normalization");`**
  - **Получение адреса функции из библиотеки**
  - `dlsym` - dynamic library symbol (символ динамической библиотеки)
  - `lib_handle` - дескриптор библиотеки
  - `"normalization"` - имя функции (строка)
  - Возвращает адрес функции, сохраняет в указатель normalization

**После этой строки:**
- Указатель normalization "знает", где находится функция в памяти
- Можно вызывать: `normalization(data, n)`

- **Строки 30-35**: проверка ошибки получения символа
  ```c
  error = dlerror();
  if (error != NULL) {
      fprintf(stderr, "%s\n", error);
      dlclose(lib_handle);
      return 1;
  }
  ```
  - `dlerror()` - проверяет, была ли ошибка
  - Если error не NULL - функцию не нашли
  - `dlclose(lib_handle)` - закрывает библиотеку перед выходом

**Конец блока `#endif` (строка 36)**

---

**Основная логика программы:**

- **Строка 38**: `printf("LOAD DATA...\n");`
  - Вывод информационного сообщения
  - `\n` - символ новой строки

- **Строки 39-40**: ввод размера и выделение памяти

- **Строка 42**: проверка успешности выделения памяти

- **Строка 43**: `input(data, n);`
  - Считывание данных с клавиатуры

- **Строки 45-46**: вывод исходных данных
  ```c
  printf("RAW DATA:\n\t");
  output(data, n);
  ```
  - `RAW DATA` - сырые (необработанные) данные
  - `\t` - символ табуляции (отступ)

- **Строки 48-51**: нормализация и вывод
  ```c
  printf("\nNORMALIZED DATA:\n\t");
  if (normalization(data, n)) {
      output(data, n);
  }
  ```
  - `\n` в начале - пустая строка перед выводом
  - Вызов `normalization(data, n)`:
    - В статическом режиме: вызов функции из data_process.c
    - В динамическом: вызов через указатель на функцию из .so
  - Если нормализация успешна - выводит данные

---

- **Строки 53-55**: сортировка и вывод
  ```c
  printf("\nSORTED NORMALIZED DATA:\n\t");
  sort(data, n);
  output(data, n);
  ```
  - Вызов функции sort из модуля sort
  - Сортирует нормализованные данные

- **Строки 57-63**: принятие решения
  ```c
  printf("\nFINAL DECISION:\n\t");
  if (make_decision(data, n)) {
      printf("YES");
  } else {
      printf("NO");
  }
  ```
  - Вызов make_decision из модуля decision
  - Выводит окончательное решение

- **Строка 65**: `free(data);`
  - Освобождение памяти

**Блок закрытия библиотеки (строки 68-70):**
```c
#ifdef USE_DYNAMIC
    dlclose(lib_handle);
#endif
```
- Если используется динамическая загрузка
- `dlclose` - выгружает библиотеку из памяти

- **Строка 72**: `return 0;`
  - Успешное завершение программы

---

**Пример вывода программы:**
```
LOAD DATA...
5
1.5 2.8 3.2 4.1 5.0

RAW DATA:
    1.50 2.80 3.20 4.10 5.00
NORMALIZED DATA:
    0.00 0.37 0.49 0.74 1.00
SORTED NORMALIZED DATA:
    0.00 0.37 0.49 0.74 1.00
FINAL DECISION:
    YES
```

---

#### 4.4.2. Файл sort.h

```c
#ifndef SORT_H
#define SORT_H

void sort(double *data, int n);

#endif
```

**Разбор:**
- Защита от повторного включения
- Объявление функции сортировки
- `void` - функция не возвращает значение
- Сортирует массив "на месте" (изменяет исходный массив)

---

#### 4.4.3. Файл sort.c

```c
#include "sort.h"

void sort(double *data, int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (data[j] > data[j + 1]) {
                double temp = data[j];
                data[j] = data[j + 1];
                data[j + 1] = temp;
            }
        }
    }
}
```

**Разбор построчно:**

- **Строка 1**: подключает sort.h

- **Строка 3**: `void sort(double *data, int n) {`
  - Начало функции сортировки

- **Строка 4**: `for (int i = 0; i < n - 1; i++) {`
  - **Внешний цикл**: проходы по массиву
  - Выполняется n-1 раз
  - Каждый проход "всплывает" один максимальный элемент в конец

- **Строка 5**: `for (int j = 0; j < n - i - 1; j++) {`
  - **Внутренний цикл**: сравнение соседних элементов
  - `n - i - 1` - с каждым проходом проверяем меньше элементов
  - Потому что конец массива уже отсортирован

- **Строка 6**: `if (data[j] > data[j + 1]) {`
  - Сравнение двух соседних элементов
  - Если левый больше правого - нужно поменять местами

- **Строки 7-9**: обмен элементов (swap)
  ```c
  double temp = data[j];
  data[j] = data[j + 1];
  data[j + 1] = temp;
  ```
  - Классический алгоритм обмена через временную переменную
  - `temp` - хранит значение первого элемента
  - Перезаписываем первый элемент вторым
  - Записываем сохраненное значение во второй элемент

**Алгоритм: Пузырьковая сортировка (Bubble Sort)**

**Принцип работы:**
1. Проходим по массиву, сравнивая соседние элементы
2. Если они в неправильном порядке - меняем местами
3. Повторяем, пока весь массив не отсортируется
4. Большие элементы "всплывают" в конец (как пузыри)

**Визуализация:**
```
Исходный массив: [5, 2, 8, 1, 9]

Проход 1:
[5, 2, 8, 1, 9]  5 > 2 → меняем
[2, 5, 8, 1, 9]  5 < 8 → не меняем
[2, 5, 8, 1, 9]  8 > 1 → меняем
[2, 5, 1, 8, 9]  8 < 9 → не меняем
Результат: [2, 5, 1, 8, 9]  (9 на месте)

Проход 2:
[2, 5, 1, 8, 9]  2 < 5 → не меняем
[2, 5, 1, 8, 9]  5 > 1 → меняем
[2, 1, 5, 8, 9]  5 < 8 → не меняем
Результат: [2, 1, 5, 8, 9]  (8, 9 на месте)

Проход 3:
[2, 1, 5, 8, 9]  2 > 1 → меняем
[1, 2, 5, 8, 9]  2 < 5 → не меняем
Результат: [1, 2, 5, 8, 9]  (5, 8, 9 на месте)

Проход 4:
[1, 2, 5, 8, 9]  1 < 2 → не меняем
Результат: [1, 2, 5, 8, 9]  (весь массив отсортирован)
```

**Сложность алгоритма:**
- Время: O(n²) - квадратичная (медленная для больших массивов)
- Память: O(1) - сортирует на месте (не требует дополнительной памяти)

**Почему используется:**
- Простота реализации
- Не требует дополнительной памяти
- Для учебных целей подходит

---

## Система сборки Makefile

Makefile автоматизирует процесс компиляции программы.

### Файл Makefile

```makefile
CC = gcc
CFLAGS = -Wall -Werror -Wextra -std=c11 -I../data_libs -I../data_module -I../yet_another_decision_module
LDFLAGS = -lm

BUILD_DIR = ../../build
TARGET = $(BUILD_DIR)/Quest_3
TARGET_STATIC = $(BUILD_DIR)/Quest_5
TARGET_DYNAMIC = $(BUILD_DIR)/Quest_6
```

**Разбор построчно:**

- **Строка 1: `CC = gcc`**
  - Определение переменной CC (C Compiler)
  - `gcc` - GNU Compiler Collection (компилятор C)
  - В Makefile переменные обращаются как $(CC)

- **Строка 2: `CFLAGS = ...`**
  - Флаги (опции) компиляции
  - `-Wall` - включить все (all) предупреждения
  - `-Werror` - считать предупреждения ошибками
  - `-Wextra` - дополнительные предупреждения
  - `-std=c11` - использовать стандарт C11
  - `-I../data_libs` - добавить директорию для поиска заголовочных файлов
    - `-I` (Include) - путь к .h файлам
    - Можно писать `#include "data_io.h"` вместо `#include "../data_libs/data_io.h"`

- **Строка 3: `LDFLAGS = -lm`**
  - Флаги линковки (связывания)
  - `-lm` - подключить математическую библиотеку
    - `l` = library
    - `m` = math
  - Нужна для функций sqrt, fabs

- **Строки 5-8**: пути и имена целевых файлов
  - `BUILD_DIR` - папка для результатов компиляции
  - `TARGET` - имя исполняемого файла для Quest 3
  - `$(BUILD_DIR)` - обращение к переменной

---

```makefile
SRCS = main_executable_module.c \
       sort.c \
       ../data_libs/data_io.c \
       ../data_libs/data_stat.c \
       ../data_module/data_process.c \
       ../yet_another_decision_module/decision.c
```

- **Переменная SRCS** (sources - исходники)
  - Список всех .c файлов для компиляции
  - `\` в конце строки - продолжение на следующей строке
  - Перечислены все модули, которые нужны для программы

---

```makefile
SRCS_STATIC = main_executable_module.c \
              sort.c \
              ../data_libs/data_io.c \
              ../data_module/data_process.c \
              ../yet_another_decision_module/decision.c
```

- **Переменная SRCS_STATIC**
  - Для сборки со статической библиотекой
  - Отличие: нет `data_stat.c` (он будет в библиотеке data_stat.a)

---

```makefile
SRCS_DYNAMIC = main_executable_module.c \
               sort.c \
               ../data_libs/data_io.c \
               ../data_libs/data_stat.c \
               ../yet_another_decision_module/decision.c
```

- **Переменная SRCS_DYNAMIC**
  - Для сборки с динамической библиотекой
  - Отличие: нет `data_process.c` (он будет в data_process.so)

---

```makefile
OBJS = $(SRCS:.c=.o)
OBJS_STATIC = $(SRCS_STATIC:.c=.o)
OBJS_DYNAMIC = $(SRCS_DYNAMIC:.c=.o)
```

- **Автоматическое преобразование**
  - `$(SRCS:.c=.o)` - заменяет расширение .c на .o
  - Результат: список объектных файлов
  - Объектный файл (.o) - скомпилированный, но не слинкованный код

**Пример:**
```
SRCS = file1.c file2.c
OBJS = file1.o file2.o  (автоматически)
```

---

```makefile
DATA_STAT_LIB = ../data_libs/data_stat.a
DATA_STAT_OBJ = ../data_libs/data_stat.o

DATA_PROCESS_LIB = ../data_module/data_process.so
DATA_PROCESS_OBJ = ../data_module/data_process_pic.o
```

- **Переменные для библиотек**
  - `DATA_STAT_LIB` - путь к статической библиотеке
    - `.a` - расширение для статических библиотек (archive)
  - `DATA_PROCESS_LIB` - путь к динамической библиотеке
    - `.so` - shared object (разделяемый объект)
  - `_pic.o` - position-independent code (позиционно-независимый код)
    - Нужен для динамических библиотек

---

```makefile
all: $(TARGET)
```

- **Цель all**
  - Цель по умолчанию (первая в файле)
  - Вызывается командой `make` без параметров
  - Зависит от $(TARGET), т.е. от ../../build/Quest_3

**Как работают цели Makefile:**
```
цель: зависимости
    команды
```
- Если зависимости новее цели - выполняются команды
- Если цель не существует - выполняются команды

---

```makefile
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)
```

- **Цель для создания директории**
  - Если папка build не существует - создает её
  - `mkdir -p` - создать директорию (и все родительские)
  - `-p` - не выдавать ошибку, если уже существует

---

```makefile
$(TARGET): $(OBJS) | $(BUILD_DIR)
	$(CC) $(OBJS) -o $(TARGET) $(LDFLAGS)
```

- **Цель для основной программы**
  - Зависит от всех объектных файлов (.o)
  - `| $(BUILD_DIR)` - order-only prerequisite
    - Создать директорию, если её нет
    - Но не пересобирать, если директория изменилась
  - **Команда**: `$(CC) $(OBJS) -o $(TARGET) $(LDFLAGS)`
    - `$(CC)` - компилятор (gcc)
    - `$(OBJS)` - все объектные файлы
    - `-o $(TARGET)` - имя выходного файла
    - `$(LDFLAGS)` - флаги линковки (-lm)

**Что делает команда:**
- Связывает (линкует) все .o файлы в один исполняемый файл
- Подключает математическую библиотеку

---

```makefile
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@
```

- **Шаблонное правило** (pattern rule)
  - `%.o: %.c` - для любого файла .o найти соответствующий .c
  - `$<` - первая зависимость (файл .c)
  - `$@` - цель (файл .o)
  - `-c` - только компиляция (без линковки)

**Пример:**
```
Для main.o:
  $< = main.c
  $@ = main.o
  Команда: gcc -Wall ... -c main.c -o main.o
```

**Что делает:**
- Компилирует каждый .c файл в отдельный .o файл
- Проверяет синтаксис, создает машинный код

---

```makefile
$(DATA_STAT_OBJ): ../data_libs/data_stat.c
	$(CC) $(CFLAGS) -c ../data_libs/data_stat.c -o $(DATA_STAT_OBJ)

data_stat.a: $(DATA_STAT_OBJ)
	ar rcs $(DATA_STAT_LIB) $(DATA_STAT_OBJ)
```

- **Создание статической библиотеки**
  - Сначала компилируется data_stat.c в .o
  - Затем создается архив (.a) из объектного файла
  - `ar` - archiver (архиватор)
  - `rcs` - флаги:
    - `r` - replace (заменить файлы в архиве)
    - `c` - create (создать архив)
    - `s` - index (создать индекс)

**Статическая библиотека:**
- Просто архив объектных файлов
- Код из библиотеки копируется в исполняемый файл при линковке
- Увеличивает размер программы, но нет зависимости от внешних файлов

---

```makefile
build_with_static: data_stat.a $(OBJS_STATIC) | $(BUILD_DIR)
	$(CC) $(OBJS_STATIC) $(DATA_STAT_LIB) -o $(TARGET_STATIC) $(LDFLAGS)
```

- **Цель для сборки со статической библиотекой**
  - Зависит от data_stat.a и объектных файлов
  - Линкует программу с использованием библиотеки

---

```makefile
$(DATA_PROCESS_OBJ): ../data_module/data_process.c
	$(CC) $(CFLAGS) -fPIC -c ../data_module/data_process.c -o $(DATA_PROCESS_OBJ)

data_process.so: $(DATA_PROCESS_OBJ) $(DATA_STAT_OBJ)
	$(CC) -shared $(DATA_PROCESS_OBJ) $(DATA_STAT_OBJ) -o $(DATA_PROCESS_LIB) $(LDFLAGS)
```

- **Создание динамической библиотеки**
  - `-fPIC` - флаг для позиционно-независимого кода
    - PIC = Position Independent Code
    - Код может загружаться по любому адресу в памяти
    - Обязателен для динамических библиотек

  - `-shared` - создать разделяемую библиотеку
  - Включает два объектных файла: data_process и data_stat

**Динамическая библиотека:**
- Загружается во время выполнения программы
- Код не копируется в исполняемый файл
- Несколько программ могут использовать одну библиотеку
- Меньший размер программы, но зависимость от .so файла

---

```makefile
main_executable_module_dynamic.o: main_executable_module.c
	$(CC) $(CFLAGS) -DUSE_DYNAMIC -c main_executable_module.c -o main_executable_module_dynamic.o
```

- **Компиляция для динамического режима**
  - `-DUSE_DYNAMIC` - определяет макрос USE_DYNAMIC
    - `-D` = define
    - Эквивалентно `#define USE_DYNAMIC` в коде
  - Создает отдельный .o файл для динамической версии

---

```makefile
build_with_dynamic: data_process.so main_executable_module_dynamic.o sort.o ../data_libs/data_io.o ../data_libs/data_stat.o ../yet_another_decision_module/decision.o | $(BUILD_DIR)
	$(CC) main_executable_module_dynamic.o sort.o ../data_libs/data_io.o ../data_libs/data_stat.o ../yet_another_decision_module/decision.o -o $(TARGET_DYNAMIC) $(LDFLAGS) -ldl
```

- **Цель для сборки с динамической библиотекой**
  - Линкует программу с флагом `-ldl`
  - `-ldl` - подключить библиотеку dl (dynamic linking)
    - Нужна для функций dlopen, dlsym, dlclose

---

```makefile
clean:
	rm -f $(OBJS) $(OBJS_STATIC) $(OBJS_DYNAMIC) $(DATA_STAT_OBJ) $(DATA_STAT_LIB) $(DATA_PROCESS_OBJ) $(DATA_PROCESS_LIB) main_executable_module_dynamic.o $(TARGET) $(TARGET_STATIC) $(TARGET_DYNAMIC)
```

- **Цель clean**
  - Удаляет все сгенерированные файлы
  - `rm -f` - remove force (удалить без подтверждения)
  - Удаляет:
    - Все объектные файлы (.o)
    - Библиотеки (.a, .so)
    - Исполняемые файлы

**Использование:**
```bash
make clean  # Очистить проект
```

---

```makefile
rebuild: clean all
```

- **Цель rebuild**
  - Сначала выполняет clean (очистка)
  - Затем all (пересборка)
  - Полная пересборка проекта с нуля

**Использование:**
```bash
make rebuild  # Пересобрать полностью
```

---

```makefile
.PHONY: all clean rebuild data_stat.a build_with_static data_process.so build_with_dynamic
```

- **Объявление фиктивных целей**
  - `.PHONY` - специальная цель
  - Указывает, что перечисленные цели не создают файлов
  - Всегда выполняются, даже если файл с таким именем существует

**Зачем:**
- Если создать файл с именем "clean"
- Без .PHONY: make решит, что цель выполнена
- С .PHONY: make всегда выполнит команды

---

## Взаимодействие модулей

### Схема зависимостей:

```
main_executable_module
├── data_io (ввод/вывод)
├── data_stat (статистика)
├── data_process (нормализация)
│   └── data_stat (использует max, min)
├── decision (принятие решений)
│   └── data_stat (использует mean, variance, max)
└── sort (сортировка)
```

### Поток данных:

```
1. Пользователь вводит количество и данные
       ↓
2. data_io.input() → массив заполняется
       ↓
3. data_io.output() → вывод исходных данных
       ↓
4. data_process.normalization() → данные нормализуются [0, 1]
   ├── использует data_stat.max()
   └── использует data_stat.min()
       ↓
5. data_io.output() → вывод нормализованных данных
       ↓
6. sort.sort() → данные сортируются по возрастанию
       ↓
7. data_io.output() → вывод отсортированных данных
       ↓
8. decision.make_decision() → анализ данных
   ├── использует data_stat.mean()
   ├── использует data_stat.variance()
   └── использует data_stat.max()
       ↓
9. Вывод: YES или NO
```

### Повторное использование кода:

- **data_stat** используется в:
  - data_process (max, min)
  - decision (mean, variance, max)
  - Это пример модульности: одна библиотека для разных модулей

- **data_io** используется везде:
  - data_module_entry
  - yet_another_decision_module_entry
  - main_executable_module
  - Единый интерфейс ввода/вывода

---

## Пошаговое выполнение программы

### Пример полного выполнения main_executable_module:

**Ввод:**
```
5
10 20 30 40 50
```

**Шаги выполнения:**

1. **Инициализация:**
   ```
   int n;
   double *data;
   ```
   - Создаются переменные (значения неопределенны)

2. **Считывание количества:**
   ```
   scanf("%d", &n);  → n = 5
   ```

3. **Выделение памяти:**
   ```
   data = malloc(5 * sizeof(double));
   ```
   - Выделяется память для 5 чисел double
   - data теперь указывает на блок памяти

4. **Проверка:**
   ```
   if (data != NULL)  → true (память выделена)
   ```

5. **Ввод данных:**
   ```
   input(data, 5);
   ```
   - Вызов функции из data_io.c
   - Цикл считывает 5 чисел:
     - data[0] = 10.0
     - data[1] = 20.0
     - data[2] = 30.0
     - data[3] = 40.0
     - data[4] = 50.0

6. **Вывод исходных данных:**
   ```
   printf("RAW DATA:\n\t");
   output(data, 5);
   ```
   - Вывод: `10.00 20.00 30.00 40.00 50.00`

7. **Нормализация:**
   ```
   normalization(data, 5);
   ```
   - Вызов из data_process.c
   - Внутри:
     ```
     max_value = max(data, 5) = 50.0
     min_value = min(data, 5) = 10.0
     size = 50.0 - 10.0 = 40.0

     fabs(40.0) >= 1E-6  → true

     Цикл нормализации:
     data[0] = (10-10)/40 = 0.00
     data[1] = (20-10)/40 = 0.25
     data[2] = (30-10)/40 = 0.50
     data[3] = (40-10)/40 = 0.75
     data[4] = (50-10)/40 = 1.00

     return 1 (успех)
     ```

8. **Вывод нормализованных данных:**
   ```
   output(data, 5);
   ```
   - Вывод: `0.00 0.25 0.50 0.75 1.00`

9. **Сортировка:**
   ```
   sort(data, 5);
   ```
   - Данные уже отсортированы
   - Массив не изменится

10. **Вывод отсортированных данных:**
    ```
    output(data, 5);
    ```
    - Вывод: `0.00 0.25 0.50 0.75 1.00`

11. **Принятие решения:**
    ```
    make_decision(data, 5);
    ```
    - Вызов из decision.c
    - Внутри:
      ```
      m = mean(data, 5) = (0+0.25+0.5+0.75+1)/5 = 0.5
      variance = ... (примерно 0.125)
      sigma = sqrt(0.125) ≈ 0.35
      max_value = 1.0

      Проверки:
      1. 1.0 <= 0.5 + 3*0.35 = 1.55  ✓
      2. 1.0 >= 0.5 - 3*0.35 = -0.55  ✓
      3. 0.5 >= 0.666  ✗ (ЛОЖЬ!)

      decision = 1 & (true & true & false) = 1 & false = 0
      return 0
      ```

12. **Вывод решения:**
    ```
    printf("NO");
    ```
    - Условие 3 не выполнено (среднее < 0.666)

13. **Освобождение памяти:**
    ```
    free(data);
    ```
    - Память возвращена системе

14. **Завершение:**
    ```
    return 0;
    ```
    - Программа успешно завершилась

**Полный вывод:**
```
LOAD DATA...
5
10 20 30 40 50
RAW DATA:
    10.00 20.00 30.00 40.00 50.00
NORMALIZED DATA:
    0.00 0.25 0.50 0.75 1.00
SORTED NORMALIZED DATA:
    0.00 0.25 0.50 0.75 1.00
FINAL DECISION:
    NO
```

---

## Команды сборки и запуска

### Базовая сборка (Quest 3):
```bash
cd src/main_executable_module
make all
../../build/Quest_3
```

### Со статической библиотекой (Quest 5):
```bash
make build_with_static
../../build/Quest_5
```

### С динамической библиотекой (Quest 6):
```bash
make build_with_dynamic
export LD_LIBRARY_PATH=../data_module:$LD_LIBRARY_PATH
../../build/Quest_6
```

**Примечание:** для динамической библиотеки нужно указать путь, где её искать

### Очистка проекта:
```bash
make clean
```

### Полная пересборка:
```bash
make rebuild
```

---

## Ключевые концепции программирования

### 1. Указатели

**Что это:**
- Переменная, хранящая адрес в памяти

**Обозначения:**
```c
int *ptr;        // Указатель на int
double *data;    // Указатель на double
char *string;    // Указатель на char
```

**Операции:**
```c
int x = 10;
int *ptr = &x;   // ptr хранит адрес x
int y = *ptr;    // y = 10 (разыменование)
```

### 2. Массивы и указатели

**Связь:**
```c
double arr[5];
double *ptr = arr;  // Имя массива - это указатель на первый элемент

arr[2] == *(arr + 2)  // Эквивалентные обращения
```

### 3. Динамическая память

**Выделение:**
```c
double *data = (double *)malloc(n * sizeof(double));
```

**Освобождение:**
```c
free(data);
```

**Правило:** каждому malloc должен соответствовать free!

### 4. Передача по указателю

**Зачем:**
```c
void change(double *x) {
    *x = 10;  // Изменяет оригинал
}

int main() {
    double a = 5;
    change(&a);   // Передаем адрес
    // a теперь 10
}
```

**Массивы всегда передаются по указателю**

### 5. Препроцессор

**Директивы:**
```c
#include <file.h>    // Подключить системный файл
#include "file.h"    // Подключить локальный файл
#define NAME value   // Определить константу
#ifdef MACRO         // Условная компиляция
```

### 6. Модульность

**Принцип:**
- Заголовочный файл (.h) - интерфейс (что доступно)
- Исходный файл (.c) - реализация (как работает)

**Преимущества:**
- Повторное использование кода
- Легче поддерживать
- Можно компилировать отдельно

### 7. Библиотеки

**Статическая (.a):**
- Код встраивается в программу
- Больше размер
- Нет зависимостей

**Динамическая (.so):**
- Загружается во время выполнения
- Меньше размер
- Требует .so файл

---

## Заключение

Этот проект демонстрирует основы модульного программирования на C:

1. **Разделение ответственности**: каждый модуль решает свою задачу
2. **Повторное использование**: функции из data_libs используются везде
3. **Абстракция**: main не знает, как работают функции (только интерфейс)
4. **Автоматизация**: Makefile упрощает сборку
5. **Гибкость**: можно собирать разными способами (статика/динамика)

Программа обрабатывает данные в несколько этапов:
- Ввод → Нормализация → Сортировка → Принятие решения

Каждый этап реализован отдельным модулем, что делает код понятным и поддерживаемым.
